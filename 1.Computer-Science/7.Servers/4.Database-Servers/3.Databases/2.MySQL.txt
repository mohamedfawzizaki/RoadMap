_______________________________________________________________________________________________________________________________________
                                                    MySql
_______________________________________________________________________________________________________________________________________
Basic SQL Concepts:
       ACID (Atomicity, Consistency, Isolation, Durability)
        __________________________________________________________ 
       | 1_Basics.                          12_Cursors.           |
       | 2_Sql_Languages.                   13_Triggers.          |
       | 3_SQL_Fuctions.                    14_Anonymous_Blocks.  |
       | 4_Joins.                           15_Procedures.        |
       | 5_SubQuery.                        16_Functions.         |
       | 6_Data_Dictionary.                 17_Packages.          |
       | 7_DataBase_Objects.                18_Clusters.          |
       | 8_partitions.                      19_Injections.        |
       | 9_Dependencies.                    20_Transactions.      |
       | 10_Pseudocolumns.                  21_Exception_Handling.|
       | 11_Indexes.                        22_Bulk_Binding.      |
       |__________________________________________________________|
       
Advanced SQL Concepts: 
        _____________________________________________________________
       |                                                             |      
       | 1_DBA / Users / Schema / Object / Privilege.                |                       
       | 2_Explain Plan.                    11_DataBase Backup.      |
       | 3_SQL Loader.                      12_DataBase Migration.   | 
       | 4_Dynamic SQL.                     13_Database Integrity.   |        
       | 5_DataBase directories.            14_Database Security.    |         
       | 6_External Tables.                 15_Database Links.       |   
       | 7_File Handling.                   16_Query Analysis.       |
       | 8_Mail Handling.                   17_Query Optimization.   |
       | 9_File Organization.               18_Design Consideration  |
       | 10_Data Pump.                      19_Database Hosting.     | 
       |                                    20_Database Normalization|                     
       |_____________________________________________________________|
       
_______________________________________________________________________________________________________________________________________
_____________________________________________________SQL Language______________________________________________________________________
Explaination:
            - https://dev.mysql.com/
            - https://dev.mysql.com/doc/refman/8.3/en/\
            - https://mariadb.org/documentation/
            - https://sqlfiddle.com/
            - https://sqlfiddle.com/mysql/online-compiler?id=51203449-1751-496a-93f1-cf7cc5873705
            
            - https://www.tutorialspoint.com/sql/index.htm
            - https://www.javatpoint.com/sql-tutorial
            - https://www.youtube.com/watch?v=mt6Go-VGL0A&list=PLTChhmU8tbQzrdP79gFX6h4TXu-gOUDvp&pp=iAQB
       Exam : ExamCollection : 
              https://www.youtube.com/watch?v=jDm9tF4YNnI&list=PLTChhmU8tbQzrdP79gFX6h4TXu-gOUDvp&index=69&pp=iAQB


Tools for dealing with DataBases :

       1.Commands Lines  : 'system tool'.
       2.phpMyAdmin      : 'web tool'.
       3.MYSQL Workbench : 'desctop application'.

Dealing with DataBases :
       1.DataBase: 
                  "CREATE DATABASE db_name;"
                  "CREATE DAATBASE IF NOT EXISTS db_name;"

                  "SHOW DATABASES;"
                  "SHOW DATABASES LIKE 'db_name;"

                  "SELECT DATABASE();"
                  "SELECT VERSION();"
                  "SELECT USER();"
                  "SELECT SESSION_USER();"
                  "SELECT SYSTEM_USER();"
                  "SELECT CONNECTION_ID();"
                  "SELECT CHARSET(USER());" 
                  "SELECT CHARSET(CONVERT(USER() USING latin1));"


                         

                  "USE db_name;"

                  "DROP DATABASE db_name;"
                  "DROP DATABASE IF EXISTS db_name;"
       2.Users:
                  ""
                  ""

                  "SELECT USER();"
                  "SELECT SESSION_USER();"
                  "SELECT SYSTEM_USER();"
                  "SELECT CHARSET(USER());" 
       3.Tables:
                  "CREATE TABLE tab_name;"
                  "CREATE TABLE IF NOT EXISTS tab_name;"

                  "DESCRIBLE tab_name;"

                  "SHOW CREATE TABLE tab_name;"   // shows the creation code of the table.
                  "SHOW TABLE  STATUS;"
                  "SHOW COLUMNS FROM tab_name;"
                  "SHOW FIELDS  FROM tab_name;"

                  "RENAME TABLE old_tab_name  TO new_tab_name;"
                  "RENAME TABLE old_tab1_name TO new_tab1_name , old_tab1_name TO new_tab1_name , ... ;"
                  "ALTER  TABLE old_tab_name RENAME new_tab_name;"

                  "ALTER TABLE tab_name ENGINE = eng_name;"  // alter storage engine.
                  "ALTER TABLE tab_name CONVERT TO CHARACTER SET colla_name" // alter collation name like utf8.

                  "DROP TABLE tab_name;"
                  "DROP TABLE IF EXISTS tab_name;"                     
Basic SQL Concepts:
        __________________________________________________________ 
       | 1_Basics.                          12_Cursors.           |
       | 2_Sql_Languages.                   13_Triggers.          |
       | 3_SQL_Fuctions.                    14_Anonymous_Blocks.  |
       | 4_Joins.                           15_Procedures.        |
       | 5_SubQuery.                        16_Functions.         |
       | 6_Data_Dictionary.                 17_Packages.          |
       | 7_DataBase_Objects.                18_Clusters.          |
       | 8_partitions.                      19_Injections.        |
       | 9_Dependencies.                    20_Transactions.      |
       | 10_Pseudocolumns.                  21_Exception_Handling.|
       |                                    22_Bulk_Binding.      |
       |__________________________________________________________|
       
Advanced SQL Concepts: 
        ___________________________________________________________
       |                                                           |      
       | 1_DBA / Users / Schema / Object / Privilege.              |                       
       | 2_Explain Plan.                    11_DataBase Backup.    |
       | 3_SQL Loader.                      12_DataBase Migration. | 
       | 4_Dynamic SQL.                     13_Database Integrity. |        
       | 5_DataBase directories.            14_Database Security.  |         
       | 6_External Tables.                 15_Database Links.     |   
       | 7_File Handling.                   16_Query Analysis.     |
       | 8_Mail Handling.                   17_Query Optimization. |
       | 9_File Organization.               18_Design Consideration|
       | 10_Data Pump.                      19_Database Hosting.   |                     
       |___________________________________________________________|
More Advanced SQL Concepts:
        ___________________________________________________________
       |                                                           | 
       | 1_Time Zone.                                              |
       | 2_Recursive Query.                                        |
       | 4_Window Function.                                        |       
       | 5_Common Table Expression "CTEs".                         |
       | 6_Storage Engine.                                         |
       | 7_Collations.                                             |
       | 8_IBD.
       | 9_MYSQLi.
       | 10_PDO. 
       |___________________________________________________________|
/*_________________________________________________________________________________________________________             
___________________________________________________________________________________________________________
__________________________________________________________________________________________________________*/            

____________________________________________ Basic SQL Concepts_____________________________________________
           -> https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Introduction-to-Oracle-SQL.html#GUID-049B7AE8-11E1-4110-B3E4-D117907D77AC
           -> https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Basic-Elements-of-Oracle-SQL.html#GUID-41D065C3-3449-4DAE-B2D8-4DF256FFC88A

 _Sql Basics:
               
     1.General Commands:
             _DESCRIBE or DESC command:
                    -> It is used to display the structure of the object"Table".
                    Forms:
                            DESCRIBE table_name;
                            DESC     table_name;
                    Example:
                            DESCRIBE employee;
                            Desc     employee;        
  
             _DEFINE Command:
                    -> It is used to define and assign a value to the variable.
                    -> the variable becomes like "general variable in c++".
                    Forms:
                            DEFINE var_name;
                            DEFINE var_name = value;
                    Example:
                           'DEFINE EMPLOYEE_NUMBER = 5;

                            Select * 
                            From employee
                            Where emp_id = &EMPLOYEE_NUMBER;
                            
                            UNDEFINE EMPLOYEE_NUMBER;'

             _UNDEFINE Command:
                    -> It is used to remove a variable.
             _
     2_Comments:
             _Single Line Comment :
                         -- text  
             _Multiple Lines Comment :
                         /*
                          text
                         */

     3_DataTypes:
             _Numeric Datatype:
                    -> Integers:
                            "TINYINT":
                                     ->    
                            "SMALLINT":
                                     -> 
                            "MEDIUMINT":
                                     -> 
                            "INT":
                                     -> 
                            "BIGINT":
                                     -> 
                    -> Decimals:
                            "DECIMAL":
                                     -> 
                            "FLOAT":
                                     -> 
                            "DOUBLE":
                                     -> 
                            "REAL":   
                                     ->     
                    -> Others:
                            "BIT":
                                     ->
                            "BOOLEAN":
                                     ->
                            "SERIAL":  
                                     ->                     
             _Strings Datatypes:
                     "CHAR":
                            -> Fixed-Length-Character.
                            -> static memory.
                     "VARCHAR":
                            -> Variable-Length-Character.
                            -> dynamic memory.
                     
                     "TINYTEXT":
                     "TEXT":
                     "MEDIUMTEXT":
                     "LONGTEXT":

                     "TINYBLOB":
                     "BLOB":
                     "MEDIUMBLOB":
                     "LONGBLOB":

                     "BINARY":
                     "VARBINARY":

                     "ENUM":
                     "SET":

             _Date and Time Datatypes:
                     "DATE": 
                             -> It stores date only. 
                     "TIME": 
                             -> It stores time only.
                     "DATETIME": 
                             -> It stores both date and time. 
                     "TIMESTAMP":
                             -> It stores both date and time.   
                     "YEAR":
                             -> It stores the year.


                     "TIMESTAMP WITH TIME ZONE":
                                           -> It stores .
                     "TIMESTAMP WITH LOCAL TIME ZONE": 
                                           -> It stores .
                     -> Functions used to manpulate date and time:
                                    "to_char":
                                    "to_date":
                                    "NOW()":
                                    "CURDATE()":
                                    "CURTIME()":
                                    3.DBTIMEZONE.
                                    4.SESSIONTIMEZONE.
                                    5.LOCALTIMESTAMP.
                                    6.TZ_OFFSET.
                                    7.FROM_TZ.
                                    8.TO_TIMESTAMP.
                                    9.TO_YMINTERVAL.
                                    10.TO_DSINTERVAL.
                                    11.EXTRACT.
                                    12.ALTER SESSION SET TIME_ZONE.
                     -> Note : "V$TIMEZONE_NAMES" dictionary view.               
                     Syntax:
                           "----------------------------------------------- 
                            CREATE TABLE table_name
                             (
                                    date1  DATE,
                                    date2  TIMESTAMP,
                                    date3  TIMESTAMP WITH TIME ZONE,
                                    date4  TIMESTAMP WITH LOCAL TIME ZONE
                             ); 
                            -----------------------------------------------"               
             -----------------------------------------------------------------------------------------
             _Long:
                         -> Variable-Length-Character.
                         -> It can hold characters more than Varchar2.
             _CLOB:
                         -> Character-large-Object containing single byte or multibyte charachters.
                         -> It can hold characters more than 'Varchar2' and 'Long' datatypes.
             _NCLOB:
                         -> Character-large-Object containing Unicode charachters.
                         -> It can hold characters more than 'Varchar2' and 'Long' datatypes.
                         -> N = National.
             ---------------------------------------------------------------------------------------                        
             _Raw(size):
                         -> Raw Binary Data of length size bytes.
             _Long Raw:
                         -> Raw Binary Data of variable length size bytes.
             _BLOB:
                         -> Binary-Large-Object. 
             
             _BFILE:
                         -> Binary Data stored in an External File.
             ---------------------------------------------------------------------------------------
             _RowID:
                         -> It represents the unique address of a row in its table.
                         -> This datatype is primariy for values returned by ROWID Pseudocolumn.
             ---------------------------------------------------------------------------------------
   
        _Datatype Conversion:
                            -> "implicit conversion" by MySql :
                                      Expression : 
                                                 from 'VARCHAR2' or 'Char' to NUMBER
                                                 from 'VARCHAR2' or 'Char' to DATE
                                                 Example:
                                                        "Select * From employee
                                                         Where emp_id = '100'
                                                         Or hire_data = '21-SEP-05'"
                                      Expression Evaluation : 
                                                 from NUMBER to 'VARCHAR2' or 'Char'
                                                 from DATE   to 'VARCHAR2' or 'Char'
                                                 Example:
                                                        "Select concat(emp_id , first_name),
                                                         concat(hire_date , first_name),
                                                         From employee;"                   
                            -> "explicit conversion" by conversion Functions:
                                      to_date()
 
     4_Constraints:
         Guidlines:
              -> It is used to prevent invalid data entry into tables.
              -> It prevents dropping of a table if there are dependencies from other tables"FK".
              -> Y can name the constraint or the server will generate a random name for it.
              -> All constraints are stored in the Data Dictionary table 'USER_CONSTRAINTS'.
              -> The constraint can be created either:
                          1_while creation of the table using 'Create Statement'.
                          2_After creation of the table using 'Alter Statement'.
              -> Y can define the constraint at either:
                          1_Column Level.
                          2_Table Level'(Most Practice)'.
              ->"NOT NULL" Constraint must be defined at the 'Column Level'.
              -> Constraints that apply to more than one column must be defined at the 'Table Level'.           
              -> 
              -> Constraint_Types : 'NOT NULL'/'Unique'/'Check'/'Primary Key'/'Foreign Key'/ 
         Types:
              __________________ 
              _"NOT NULL":
                        -> It specifies that the column can not contain a NULL value.     
              _"Unique":
                        -> It specifies a column or combination of columns whose values must be unique.
                        -> It accepts NULL values but Composite Unique Key deals with NULLs as any value.  
              _"Check":
                        -> It specifies a condition that must be true, and each row must satisfy.
                        -> 
                        Syntax: Check(col_name op value)
              _"Primary Key":
                        -> Uniquely identifies each row of the table.
                        -> It is equal to both "NOT NULL" and "Unique" constraints together. 
                        -> Only one primary key can be added to the table.
              _"Foreign Key":   
                        -> It establishes and enforces a referential integrity.
                        -> It must match an existing value in the parent table or be NULL.
                        -> It is put in the 'child table'.
                        -> NOTE : 
                               "ON DELETE CASCADE"            "ON UPDATE CASCADE"
                               "ON DELETE SET NULL"           "ON UPDATE SET NULL" 
                               "ON DELETE NO ACTION"          "ON UPDATE NO ACTION"  
                               "ON DELETE RESTRICT".          "ON UPDATE RESTRICT"   
              _"AUTO_INCREMENT":
              Syntax:
               /*----------------------------------------------------------------------------
               1_Column Level:
                      Create Table table_name
                             (
                                col_name DATATYPE CONSTRAINT const_name const_type,
                                col_name DATATYPE CONSTRAINT const_type,
                                col_name DATATYPE const_type ,
                                col_name DATATYPE const1 const2,
                                col_name DATATYPE Check(conditional_expression),  //check(col_name op val)
                                col_name DATATYPE CONSTRAINT const_name           // for FK.
                                                  REFERENCES refenced_table_name(refernced_column_name)
                                col_name DATATYPE CONSTRAINT const_name const_type 
                                                  DEFERRABLE INITIALY DEFERRED                  
                             ); 
               ----------------------------------------------------------------------------
               2_Table Level:
                      Create Table table_name
                             (
                                col_name DATATYPE NOT NULL AUTO_INCREMENT,
                                col_name DATATYPE,
                                col_name DATATYPE,
                                col_name DATATYPE,

                                CONSTRAINT const_name const_type(col_name),
                                CONSTRAINT const_name const_type(col_name,col_name),
                               
                                CONSTRAINT const_name Primary Key(col_name,...,...),
                                Primary Key(col_name,...,...),
                               
                                Foreign Key(col_name) 
                                REFERENCES refenced_table_name(refernced_column_name)

                                CONSTRAINT const_name Foreign Key(col_name) 
                                REFERENCES refenced_table_name(refernced_column_name)

                                CONSTRAINT const_name Foreign Key(col_name) 
                                REFERENCES refenced_table_name(refernced_column_name) ON DELETE CASCADE

                                CONSTRAINT const_name Foreign Key(col_name) 
                                REFERENCES refenced_table_name(refernced_column_name) ON DELETE SET NULL,

                                CONSTRAINT const_name const_type(col_name) DEFERRABLE INITIALY DEFERRED 
                             ) ENGINE = InnoDB;                
               ----------------------------------------------------------------------------*/                          
              __________________
              _'ADD CONSTRAINT':
                        -> It is used to add new constraint to a column.
                        Syntax:
                              /*ALTER TABLE table_name
                                ADD   CONSTRAINT const_name const_type (col_name);
                                --------------------------------------------------
                                ALTER TABLE table_name
                                ADD   col_name DATATYPE const_type;
                                --------------------------------------------------
                                ALTER TABLE table_name
                                ADD   const_type(col_name);
                                --------------------------------------------------
                                ALTER TABLE table1
                                ADD   CONSTRAINT const_name 
                                FOREIGN KEY (col1)
                                REFERENCES table2(col2)
                                ON UPDATE CASCADE
                                ON DELETE CASCADE;
                                --------------------------------------------------
                                ALTER  TABLE table_name
                                MODIFY col_name const_type;
                                --------------------------------------------------
                                ALTER  TABLE table1_name
                                MODIFY col1_name REFERENCES table2_name(col2_name);
                                --------------------------------------------------
                                ALTER TABLE table_name
                                ADD   CONSTRAINT const_name const_type(col_name) DEFERRABLE INITIALLY DEFERRED;
                                -------------------------------------------------------------------------------
                                ALTER TABLE table_name
                                ADD   CONSTRAINT const_name const_type(col_name) DEFERRABLE INITIALLY DEFERRED;*/ 
                          ___________________________________________________________________________         
              _'DISABLE CONSTRAINT':
                        Syntax:
                              /*ALTER   TABLE table_name
                                DISABLE CONSTRAINT const_name;              --useful in data migration.
                                ------------------------------
                                ALTER   TABLE table_name
                                DISABLE CONSTRAINT const_name CASCADE;      --For referencing keys*/
                          ___________________________________________________________________________ 
              _'ENABLE CONSTRAINT':
                        Syntax:
                              /*ALTER  TABLE table_name 
                                ENABLE CONSTRAINT const_name;*/
                          ___________________________________________________________________________    
              _'Deferrable CONSTRAINT':
                        -> Used to delay the action of the constrains until you commit or save.
                        -> There are two types : 
                                            1.'DEFERRABLE INITIALLY DEFERRED'.
                                            2.'DEFERRABLE INITIALLY immediate'.
                        Syntax:    
                              /*ALTER TABLE table_name
                                ADD   CONSTRAINT const_name const_type(col_name) DEFERRABLE INITIALLY DEFERRED;
                                ------------------------------------------------------------------------------
                                ALTER TABLE table_name
                                ADD   CONSTRAINT const_name const_type(col_name) DEFERRABLE INITIALLY DEFERRED;
                                ------------------------------------------------------------------------------
                                SET CONSTRAINT const_name immediate;  to cancel the action of 'DEFERRED'.
                                SET CONSTRAINT const_name DEFERRED;   to re-activate the constraint.*/
                          ___________________________________________________________________________             
                                                
              _'DROP CONSTRAINT':
                        Syntax:
                              /*ALTER TABLE table_name 
                                DROP  CONSTRAINT const_name;       // &const_name;
                                ----------------------------
                                ALTER TABLE table_name 
                                DROP  INDEX  col_name;
                                -------------------------------------
                                ALTER TABLE table_name 
                                DROP  Primary key;
                                -------------------------------------
                                ALTER TABLE table_name 
                                DROP  CONSTRAINT const_name CASCADE;    //For referencing keys
                                                                        //will drop the referenced cons(FK) 
                                ---------------------------------------
                                ALTER TABLE table_name 
                                DROP  Foreign Key const_name;
                                ---------------------------------------
                                ALTER TABLE table_name 
                                DROP COLUMN col_name CASCADE CONSTRANTS;*/                                                                                             
                          ___________________________________________________________________________
              _'RENAME CONSTRAINT':
                        Syntax:
                              /*ALTER  TABLE  table_name
                                RENAME CONSTAINT old_const_name TO new_const_name;*/                               
                          ___________________________________________________________________________                       
         Example:
             " ----------------------------------------------------------------------------
              1_Column Level:
                      Create Table employee
                             ( 
                                emp_name  Varchar2(22) CONSTRAINT not_null_const NOT NULL,
                                emp_id    Number(6)    CONSTRAINT primariy key,
                                hire_date Date         NOT NULL,
                                salary    Number(33)   Check(salary > 2000),
                                gender    Char(1)      Check(gender IN ('M','F')),
                                dept_id   Number(11),

                                CONSTRAINT fk_cn Foreign Key(dept_id) 
                                REFERENCES department(depart_id)  ON DELETE CASCADE
                             );
              ----------------------------------------------------------------------------
              2_Table Level:
                      Create Table table_name
                             (
                                emp_name  Varchar2(22) NOT NULL,
                                emp_id1   Number(6),
                                emp_id2   Number(6),
                                salary    Number(6,2), 
                                hire_date Date         NOT NULL,
                                dept_id   Number(11),

                                CONSTRAINT pk_cn Primariy Key(emp_id1,emp_id2),
                                CONSTRAINT ck_cn Check(salary IN (2333,5444)),
                                CONSTRAINT fk_cn Foreign Key(dept_id) 
                                REFERENCES department(depart_id) ON DELETE SET NULL
                             );                
              ----------------------------------------------------------------------------"                                   
     5_Cluases:
             -> The order of cluases in 'SELECT' statement is : From -> Where -> Group by -> Order by.
             "From":
                    -> It identifies the table. 
                    Forms: 
                         'Select * From table_name;
                          Select column_name From table_name;'
                    Example:
                          'Select * from employee;
                           Select emp_id , last_name from employee;'
             "Where":                  
                    -> It restricts the rows that are returned.
                    -> It follows the 'From' Cluase.
                    -> "Where" cluase does not accept "Group Functions" after it, you can use "Having" cluase. 
                    Forms: 
                          'Select * 
                           From  table_name
                           where Logical Expression;'
                    Example:
                          'Select * 
                           from employee
                           where emp_id = 5;'                   
             "Distinct":
                    -> used to avoide duplicate values.
                    -> Ii is used only in the begaining.
                    Forms:
                           'Select DISTINCT column_name From table_name'
                           'Select DISTINCT column_name1,column_name2 From table_name'
                    Example:
                           'Select DISTINCT Dept_ID from employee;
                            Select DISTINCT Dept_ID , Job_ID from employee;'     
             "Order by": 
                     -> It is used to sort the retrieved rows.
                     -> It comes last in the Select statement.
                     -> ASC  : Ascending  order, Defualt.
                     -> DESC : Descending order.
                     -> NULL values comes last  in ASC by defualt.
                     -> Y can use 'NULL LAST'.
                     -> Use 'NULL FIRST' to make NULL values in the first.
                     -> NULL values comes first in DESC.
                     Syntax:
                           order by column_name;
                           order by column_name ASC;
                           order by column_name DESC;
                           order by column_name NULL FIRST;
                           order by column_name NULL LARST;
                           order by Expression;                  //salary+100
                           order by column_name_alias;
                           order by column_name;                 //the column not in the select statement.
                           order by column_name1 , column_name2; //more than one column.
                           order by column_name1 , column_name2 DESC;
                           order by column_name1 DESC , column_name2 ASC;
                           order by column_name1 DESC , column_name2 DESC;
                           order by column_pos;                  //sort by column_pos in the select statement
                           order by column1_pos , column2_pos;   //more than one column position.
                     Example:
                           'Select * from employee;
                            order by emp_id;'

                           'Select * from employee;
                            order by emp_id ASC;'

                           'Select * from employee;
                            order by emp_id DESC;'

                           'Select * from employee;
                            order by emp_id NULL FIRST;'
                           
                           'Select * from employee;
                            order by salary+100;'
                           
                           'Select emp_id , lastname as l_name
                            from employee
                            order by l_name;'

                           'Select emp_id , lastname 
                            from employee
                            order by dept_id;'

                           'Select emp_id , lastname , salary 
                            from employee
                            order by emp_id , salary;'

                           'Select emp_id , lastname , salary 
                            from employee
                            order by emp_id , salary DESC;'

                           'Select emp_id , lastname , salary 
                            from employee
                            order by emp_id DESC, salary;'

                           'Select emp_id , lastname , salary 
                            from employee
                            order by emp_id DESC, salary DESC;'

                           'Select emp_id , lastname , salary 
                            from employee
                            order by 2;'       --equal to --order by lastname;

                           'Select emp_id , lastname , salary 
                            from employee
                            order by 1 , 3 ;'  --equal to --order by emp_id , salary;
             "FETCH":
                     -> It comes after "order by" cluase.
                     Forms:
                             FETCH FIRST number_of_rows ROWS ONLY;
                             FETCH FIRST number_of_rows ROWS WITH TIES;
                              
                             FETCH FIRST percentage PERCENT ROWS ONLY;  
                             FETCH FIRST percentage PERCENT ROWS WITH TIES;
                             
                             OFFSET start_row ROWS FETCH NEXT number_of_rows ROWS ONLY;
                             OFFSET start_row ROWS FETCH NEXT number_of_rows ROWS WITH TIES;

                             OFFSET start_row ROWS FETCH NEXT percentage PERCENT ROWS ONLY;
                             OFFSET start_row ROWS FETCH NEXT percentage PERCENT ROWS WITH TIES;
                     Example:
                            'Select emp_id , firstname 
                             From employee
                             order by emp_id
                             FETCH FIRST 5 ROWS ONLY;'  --or 'WITH TIES'

                            'Select emp_id , firstname 
                             From employee
                             order by emp_id
                             FETCH FIRST 56 PERCENT ROWS ONLY;'     --or 'WITH TIES' 

                            'Select emp_id , firstname 
                             From employee
                             order by emp_id
                             OFFSET 5 ROWS FETCH NEXT 5 ROWS ONLY;'  --start from 6 not 5

                            'Select emp_id , firstname 
                             From employee
                             order by emp_id
                             OFFSET 5 ROWS FETCH NEXT 58 PERCENT ROWS ONLY;'   --or 'WITH TIES'                           
             "Group By":
                     -> It does not accept alias name after it.
                     -> All columns in select statement should be in 'group by'.
                     Forms:
                     Example:     
             "For Update":
                     -> It is used with the 'SELECT' statement.
                     -> When it is used the RDBMS automatically obtains exclusive row-level locks on 
                        all the rows identified by the SELECT statement, no one can change any 
                        of these records until you perform a 'Commit' or 'RollBack'.
                     -> If the 'SELECT' statement attemps to lock a row that is locked by
                        another user, the RDBMS waits until the row is available, and
                        then returns the result of the 'SELECT' statement.
                     -> If y use 'NoWait', system will give you a massage if another user uses same records.
                     -> If y use 'Wait T' where T is the number of seconds that the system will
                        wait and then locks the records for you if they are not busy.    
                     -> It is terminated when 'Commit' issued. 
                     ->   
                     Syntax:
                             /*--------------------
                             Select column_list
                             From   table_name
                             Where  condition
                             For Update;    
                             -------------------- 
                             Select column_list
                             From   table_name
                             Where  condition
                             For Update NoWait;    
                             --------------------
                             Select column_list
                             From   table_name
                             Where  condition
                             For Update Wait 10;    
                             ------------------------------------------
                             Select table1.col_name , table2.col_name
                             From   table1 , table2
                             Where  table1.col = table2.col              //locks the two tables.
                             And    table2.col = 10
                             For Update;
                             ------------------------------------------
                             Select table1.col_name , table2.col_name
                             From   table1 , table2
                             Where  table1.col = table2.col              //locks table1 only.
                             And    table2.col = 10
                             For Update table1.any_column_name;
                             ------------------------------------------*/ 
                     Example:
                             "--------------------------------
                             Select emp_id, emp_name, salary
                             From   employee
                             Where  emp_id = 12
                             For Update;    
                             --------------------------------
                             Select * From employee
                             Where  emp_id = 99
                             For Update NoWait;
                             --------------------------------
                             Select * From employee
                             Where  emp_id = 99
                             For Update Wait 10;
                             --------------------------------
                             Select e.emp_id , d.name
                             From   employee e , department d
                             Where  e.dept_id = d.dept_id              //locks the two tables.
                             And    d.dept_id = 10
                             For Update;
                             ------------------------------------------
                             Select e.emp_id , d.name
                             From   employee e , department d
                             Where  e.dept_id = d.dept_id              //locks employee table only.
                             And    d.dept_id = 10
                             For Update e.emp_name;
                             ------------------------------------------"  
             "On Delete Cascade":
                     -> It indecates that when a row in 'the parent'(Deparetment) table is deleted,
                        the dependent rows in 'the child'(Employee) table are also deleted.
                     -> The defualt behaviour is called the 'Restrict Rule', which disallows the
                        update or deletion of referenced data.
                     -> Thise KeyWord can not be used in the ''Column-Level''.   
                     Syntax:
                     Example: 
             "On Delete Set NULL":
                     -> It indecates that when a row in 'the parent' table is deleted,
                        the foreign key values are set to NULL.
                     -> The defualt behaviour is called the 'Restrict Rule', which disallows the
                        update or deletion of referenced data.
                     -> Thise KeyWord can not be used in the ''Column-Level''.
                     Syntax:
                     Example:
             "BEFORE DROP":
             "WITH cluase": 
             "LIMIT":
                      Syntaxs:
                             "SELECT * FROM table_name LIMIT 3;" 
                             "SELECT * FROM table_name 
                              ORDER BY col_name DESC LIMIT 3;"                                                             
     6_Operators:
             ##Rules of Precedence :
                                 ()
                                 Arithmatic Operators  
                                 Concatination Operator
                                 Comparison Operators  
                                 Logical Operators    
             _Arithmatic Operators:
                                           +   -   *    / DIV     %    ^            
             _Concatination Operator || :
                        -> The Symbole is || .
                        -> It links columns or character string.
                        -> The Literal character string.
                        Syntax:
                                column_name1 || column_name2  
                                column_name1 || column_name2 as alias_name 
                                column_name1 || ' LCS '  || column_name2 
                                column_name1 ||q'[ LCS ]'|| column_name2
                                column_name1 ||q'( LCS )'|| column_name2
                                column_name1 ||q'{ LCS }'|| column_name2
                                column_name1 ||q'/ LCS /'|| column_name2  
                                column_name1 ||q'' LCS ''|| column_name2
                        Example:
                                Select first_name || last_name from employee;
                                Select first_name || last_name as full_name from employee;
                                Select first_name ||' '|| last_name from employee;
                                Select first_name ||' is the son of '|| last_name from employee;
                                Select first_name ||q'[ is the son of ]'|| last_name from employee; 

             _Comparison Operators:
                     -> "Single-Row/Value-Comparison-Operators(Relational Operators)":  
                                        =  >  >=  <  <=  <>  !=
                     -> "Multiple-Row/Value-Comparison-Operators":
                                -----------------------------------------------------------------------------    
                                EXISTS(set of values/Multiple_Row_SubQuery)-
                                IN (set of values/Multiple_Row_SubQuery)
                                Any(set of values/Multiple_Row_SubQuery) Preceded by Relational Operator.
                                ALL(set of values/Multiple_Row_SubQuery) Preceded by Relational Operator.
                                
                                -----------------------------------------------------------------------------
                                NOT EXISTS(set of values/Multiple_Row_SubQuery)
                                NOT IN (set of values/Multiple_Row_SubQuery)
                                NOT Any(set of values/Multiple_Row_SubQuery) Preceded by Relational Operator.
                                NOT ALL(set of values/Multiple_Row_SubQuery) Preceded by Relational Operator.
                            
                                -----------------------------------------------------------------------------

                                /*Note:  'NOT' operator can be used (IN ANY ALL) operators.
                                / Note:  Do not use 'NOT IN' when SubQuery returns some NULL values. 
                                  Note:  If there is NULL values in the 'set of values/subquery', then
                                         they will not be returned. 
                                         ------------------------------------
                                         'IN'     is equivalent to '= ANY'.
                                         'NOT IN' is equivalent to '<> ALL'.
                                         ------------------------------------  
                                         '< ANY' means less than the maximum.
                                         '> ANY' means more than the minimum.
                                         '= ANY' means equal to 'IN' operator.
                                         ------------------------------------ 
                                         '< ALL' means less than the minimum.
                                         '> ALL' means more than the maximum.
                                         '= ALL' not valid , wll return NULL.
                                         ------------------------------------*/ 
                                           
                     -> "Others Operators":                                
                                Between:  between 'lower_limit' and 'upper_limit'
                                Like:
                                          Like 's%'              --string starts   with 's'
                                          Like '%s'              --string ends     with 's'
                                          Like '%s%'             --string contains with 's'
                                          Like 's%d'             --string start with 's' and end with 'd'
                                          Like '_sama'           --string contains four letters.
                                          Like '%__%'            --string contains only two letters.
                                          Like '_s%'             --string contains 's' as second letter. 
                                          Like '%s_'             --string contains 's' as pre last letter.
                                          Like 's/_%' escape '/' --to handle special characters.
                                          Like '%/$%' escape '/'
                                          Like 's/_%' escape '/'
                                          Like '%/%'    
                                IS NULL -->> Where column_name IS NULL 
                                NOT IN(set of values)
                                Not between...and...
                                NOT Like
                                IS NOT NULL                                
                     Example:
                               'Select * from employee
                                where salary between 1000 and 2000;  --always the lower limit first.'
                                
                               'Select * from employee
                                where first_name between 'A' and 'C'

                               'Select * from employee
                                where salary IN (1000,2000,5988)'

                               'Select * from employee
                                where manager_id IN (11,13,NULL)'
                                
                               'Select * from employee
                                where first_name Like 'a%'' 
                                
                               'Select * from employee
                                wherefirst_name Like '%/$%' escape '/''
                                
                               'Select * from employee
                                where commission IS NULL'
                                
             _Logical Operators:
                                           AND            OR          XOR         NOT 
                                           &&             ||          XOR           !
                                         (T + T)       (T + T)      (T + not T)   negative
                                                       (T + F)      (not T + T) 
                                                       (F + T) 
                        -> Priority  NOT -->> AND -->> OR   
                        Forms:
                                condition1 log_op condition2
                        Example:
                                'Select * 
                                 From  employee
                                 Where emp_id = 5
                                 AND   salary <> 6666;'
             _Set Operators:
                     -> They combine the results of two or more component queries into one result.
                     -> Queries containing 'Set Operators' are called 'Compound Queries'. 
                     Types:   
                            1."UNION"    : return rows from both queries after eliminating duplications.
                            2."UNION ALL": return rows from both queries, including all duplications.
                            3."INTERSECT": return rows that are common to both queries.
                            4."MINUS"    : return rows in first query that are not found in second query.
                     Guidlines: 
                            -> It operates over all of the columns being selected.
                            -> Number of columns being selected must be the same.
                            -> Datatype of columns being selected must be in the same datatype group.
                            -> Names of the columns not need to be identical.
                            -> If you want to add columns presented in the first table and not presented
                               in the second table, you can use:
                                    1.Dommy column with the same datatype by using 'Conversion Functions'.
                                    2.Dommy column like 'Zero' with same datatype by 'value column_name'.
                                    3.'Join' of the second table with the first table..
                            -> In 'UNION', NULL values are not ignored during duplicate checking.
                            -> The output in 'UNION' is sorted in Ascending order by defualt.
                            -> The output in 'UNION ALL' is not sorted.
                            -> Reversing order of intersected tables does not alter the result.
                            -> Duplicate rows are automatically eleminated except in 'UNION ALL'.
                            -> Output is sorted in Ascending order by defualt except in 'UNION ALL'.
                            -> Cuolumn names from the first query apear in the result.
                            -> 'Order By' cluase comes in the last query, and apears only once.
                            -> 'Order By' cluase can see only column_name in the first query,
                                you can use the column number to avoid this issue.
                            -> 

                     Syntax:
                           /*Select t1.column1, t1.column2   //t1.column1 = t2.column3 in datatype.
                             From   table_name t1              
                             UNION/UNION ALL/INTEERSECT/MINUS  
                             Select t2.column3, t2.column4   //t1.column2 = t2.column4 in datatype. 
                             From   table _name t2;*/ 
              
                     Example:     
                            -------------------------------------------------- 
                            "Select"
                            "Select"
                            "Select"
                            "Select"
                            --------------------------------------------------
                            "Select emp_id EMP_ID, job_id , email
                             From   employee
                             UNION
                             Select emp_id empno, job_id, to_char(NULL) email
                             From   job_history
                             Order by emp_id;
                             -------------------------------------------------
                             Select emp_id EMP_ID, job_id , salary
                             From   employee
                             UNION
                             Select emp_id empno, job_id, 0 salary
                             From   job_history
                             Order by 1;"
                             -------------------------------------------------
             _Assignment Operator:
                                    :=
             _PIVOT / UNPIVOT OperatorS:
                     Guidlines:
                     Syntax:
                     Example:                                                            
     6_Alias:
             Guidlines:
                     -> The table alias is valid only for the current 'SELECT' statement.
                     -> You can perform 'Self Join' using table aliases.
                     -> The table aliases allow us not to use the same table name twice with a single statement. 
                     -> If we use the same table name more than one time in a single query without table aliases,
                        it will throw an error.
                     ->      
             Forms: 
                     column_name as alias_name
                     column_name    alias_name
                     column_name as "alias name"
                     column_name    "alias_name"
                     -> (_ $ #)  not usedn in the front of the name.
             Example:
                     Select lastname as L_name    from employee;
                     Select lastname    L$name#   from employee;
                     Select lastname as "L_name"  from employee;
                     Select lastname    "L  name" from employee; 


  
     7_Variables:
             _User-defined Variables:
             _Substitutional Variables: 
                           -> a user variable name preceded by & or && ampersands &var_name or &&var_name,
                           -> used to temporarily store values.
                           -> use '' when use varchar Datatype. 
                           -> when using single &  the variable will be discarded after is used.
                           -> when using double && the variable will be like when using DEFINE.
                           Forms:
                                  Entire Select statement:
                                             'Select &col1 , &col2, &col3
                                              From   &table_name
                                              Where  &col4 = &var_name
                                              Order by col5;'  
                                  Table_Name:
                                             '&table_name'  
                                  Column Expression:
                                             '&column_name'
                                  Where condition:
                                             'Where column_name = &var_name' 
                                  Order by cluase:
                                             'Order by &column_name' 
                           Example:
                                 'Select &col1 , &col2, &col3
                                  From   &table_name
                                  Where  &col4 = &var_name
                                  Order by col5;'



                                 'Select * From employee
                                  Where emp_id = &EMPLOYEE_NUMBER;'

                                 'Select * From employee
                                  Where firstname = '&name';

                                 'Select emp_id , first_name , &&column_name
                                  From employee
                                  Order by &column_name;'  
             _DEFINE Command:
                    -> It is used to define and assign a value to the variable.
                    -> the variable becomes like "general variable in c++".
                    Forms:
                            DEFINE var_name;
                            DEFINE var_name = value;
                    Example:
                           'DEFINE EMPLOYEE_NUMBER = 5;

                            Select * 
                            From employee
                            Where emp_id = &EMPLOYEE_NUMBER;
                            
                            UNDEFINE EMPLOYEE_NUMBER;'
             _UNDEFINE Command:
                    -> It is used to remove a variable.
                    From:
                           UNDEFINE var_name;                        
              
     8_Prompt: 
             _ACCEPT command:
                    -> to change the prompt massage :
                    Forms:
                            ACCEPT var_name PROMPT 'massage' ;
                            Select statement;
                            UNDEFINE var_name;
                    Example:
                            ACCEPT EMPLOYEE_NUMBER PROMPT 'Please enter employee id' ;
                            Select * 
                            From employee
                            Where emp_id = &EMPLOYEE_NUMBER;
                            UNDEFINE EMPLOYEE_NUMBER;
             _SET VERIFY ON  command:
                    -> It is use to display the Substitution variable before and after replaced it with values.
                    Forms:
                            SET VERIFY ON
                            Select * 
                            From employee
                            Where emp_id  = &EMPLOYEE_NUMBER;
                    Example: 
             _SET DEFINE OFF command:
                    -> It is used to prevent the server to display the prompt Window.
                    Forms:
                            SET DEFINE OFF;
                            Select statement;
                            SET DEFINE ON;
                    Example:
                            SET DEFINE OFF;
                            Select * 
                            From employee
                            Where dept_name like '%&a%';
                            SET DEFINE ON;        
             _SET DEFINE ON  command:         
     8_Conditional Expressions:
             -> It provides the use of (if-then-else) logic within the SQL statement.
             -> It uses Two methods:
                    -> "Case Expression":   it is available in All DBMSs.
                    -> "Decode Expression": it is only available in ORACLE. 
                    Forms:
                          -> CASE:
                                 'CASE' col or expr 'WHEN' comparison_expr1 'THEN' return_expr1
                                             'WHEN' comparison_expr2 'THEN' return_expr2
                                             'WHEN' comparison_expr3 'THEN' return_expr3
                                             'WHEN' comparison_exprN 'THEN' return_exprN
                                 'ELSE' defualt_expr
                                 'END'  alias_name  
                                 -------------------
                                 'CASE'  'WHEN' col or expr = comparison_expr1 'THEN' return_expr1
                                         'WHEN' col or expr = comparison_expr2 'THEN' return_expr2
                                         'WHEN' col or expr = comparison_expr3 'THEN' return_expr3
                                         'WHEN' col or expr = comparison_exprN 'THEN' return_exprN
                                 'ELSE' defualt_expr
                                 'END'  alias_name 
                                 -----------------
                                 -> if you did not put 'ELSE' the defualt_expr will be NULL.
                          -> DECODE:
                                 'DECODE'(col/exp , comparison_expr1 , return_expr1,
                                                    comparison_expr2 , return_expr2,
                                                    comparison_exprN , return_exprN,
                                                    defualt_exp)
                                          alias_name                  
                                 -------------------
                                 -> -> if you did not put 'defualt_exp' the defualt_expr will be NULL. 
                    Example: 
                          -> CASE:
                                 "Select first_name , job_id , salary,
                                        CASE job_id WHEN 'IT_PROG'  THEN 2*salary
                                                    WHEN 'ST_CLERK' THEN 5*salary
                                                    WHEN 'SA_REP'   THEN 3*salary
                                        ELSE  salary
                                        END  as "New Salary"
                                  From employee;"
                                 "Select first_name , job_id , salary,
                                        CASE  WHEN job_id = 'IT_PROG'  THEN 2*salary
                                              WHEN job_id = 'ST_CLERK' THEN 5*salary
                                              WHEN job_id = 'SA_REP'   THEN 3*salary
                                        ELSE  salary
                                        END  as "New Salary"
                                  From employee;"

                                 "Select first_name , job_id , salary,
                                        CASE  WHEN job_id = 'IT_PROG'  THEN 2*salary
                                              WHEN job_id = 'ST_CLERK' THEN 5*salary
                                              WHEN job_id = 'SA_REP'   THEN 3*salary
                                        END  as "New Salary"
                                  From employee;"                   
                          -> DECODE:
                                  "Select first_name , job_id , salary,
                                         DECODE(job_id, 'IT_PROG' , 2*salary,
                                                        'ST_CLERK', 5*salary,
                                                         salary) 
                                                as "New Salary"
                                  From employee;  "

                                  "Select first_name , job_id , salary,
                                         DECODE(job_id, 'IT_PROG' , 2*salary,
                                                        'ST_CLERK', 5*salary) 
                                                as "New Salary"
                                  From employee;  "                        
 _Sql Languages:  
       -> https://dev.mysql.com/doc/refman/8.3/en/sql-statements.html
       1_DDL: 
            -> https://dev.mysql.com/doc/refman/8.3/en/sql-data-definition-statements.html
            _"Create Table":
                  Guidlines:
                         -> To create a new table, you must have privilege and a storage area.
                         -> Defualt_Expr:
                                   It is used to specify a defualt value for a column.
                                   It is used to specify a value if a value is ommited in 'Insert' statement.
                                   Y can use 'Literal Values','Expressions','SQL Functions' as defualt_expr.
                                   Y can not use 'Another Column_Name' or a 'Pseudocolumn' as defualt_expr. 
                                   The defualt datatype must match the column datatype.
                         -> Creating table based on'Select SubQuery':
                                   -used to copy a table from another table. 
                                   -if no column specification are given, the column names of the table 
                                    are the same as the column names in the SubQuery.
                                   -if column specification are given, the number of columns must 
                                    equal the number of columns in the SubQuery.
                                   -the column definition can contain only column name and defualt value.
                                   -the column datatype and 'NOT NULL' constraint are passed to the new table. 
                                   -only 'NOT NULL' constraint can be inherited.
                                   -you can add constraints in the column definition.
                                   -define columns with columns names and defualt values.  
                                   -you can create empty table as a copy.
                         -> Note : 'CREATE ANY TABLE' privilege.
                         -> Y can put 'Sequence.NEXTVAL' as defualt value for primary key.
                  Syntax:
                         /*---------------------------------------------------
                         Create Table table_name
                                     (
                                        col1_name DATATYE    
                                        col2_name DATATYPE DEFUALT defualt_expr,  //defualt 'ahmed'
                                        col3_name DATATYPE const_type,
                                        col4_name DATATYPE DEFUALT defualt_expr const_type,
                                        col5_name DATATYPE DEFUALT sequence.NEXTVAL Primary Key,
                                     );
                         -----------------------------------------------------
                         Create Table Schema_name.table_name       //Y can use Schema_name or User_name.
                                     (
                                        col1_name DATATYPE,
                                        col2_name DATATYPE,
                                        col3_name DATATYPE
                                     );
                         ------------------------------------------------------            
                         Create Table table_name AS SubQuery;                                   
                         ------------------------------------------------------
                         Create Table table_name          
                                     (                                        
                                          col_name,                              
                                          col_name DEFUALT value,               
                                          ........,           
                                          ........
                                      )
                         AS SubQuery;
                         ------------------------------------------------------
                         Create Table table_name AS SELECT * FROM table_name2
                         Where A_Condition_return_False;    1=2//create an empty table has the same structure.
                         ------------------------------------------------------

                         Create Table "Table_Name"
                                     ("Col_Name" DATATYPE);
                         ------------------------------------------------------*/
                           
            _"Rename":   
                     -> It is used to rename the object(table,view).
                     -> It is used to rename a column in the table.
                     Syntax:
                           "RENAME old_obj_name TO new_obj_name;"

                           "RENAME old_obj1 TO new_obj1 , old_obj2 TO new_obj2 ;"
                           ------------------------------------------ 
                           "ALTER  TABLE  table_name
                            RENAME COLUMN old_col_name TO new_col_name;"
                     ___________________________________________________       
            _"Alter  Table":
                     -> Its used to modify the structure of the table.
                     -> 'ADD'/'Modify'/'Rename'/'Drop'/'Change'/'UNUSED'/'READ ONLY'/'READ WRITE'.
                  Uses:
                         -> Add a new column to the table.
                         -> Modify an existing column definition.
                         -> Define a defualt value for the new column.
                         -> Rename a column.
                         -> Drop   a column.
                         -----------------------------------
                         -> Add new constraint to the table.
                         -> Disable constraint in the table.
                         -> Drop    constraint from the table.
                         -> Change table to the 'Read-Only Status'.
                  Types:
                         _'ADD':
                               -> Used to add a new column to the table.
                               -> Y can not specify where the column is to appear.
                               -> The new column becomes the last column.
                               -> if the table aready contains rows when a column is added,
                                  the new column is initially NULL or takes the defualt value
                                  that y specified in the defualt_expr.
                               -> Y cannot add NOT NULL constraint to that column if the table 
                                  already has some rows, y can do that if there is defualt_expr.   
                            Syntax:
                              'ALTER TABLE table_name 
                               ADD   col_name1 DATATYPE, col_name2 DATATYPE DEFUALT value CONST, ...;'

                              'ALTER TABLE table_name 
                               ADD   col_name1 DATATYPE AFTER col_name;'

                              'ALTER TABLE table_name 
                               ADD   col_name1 DATATYPE FIRST;'
                               -----------------------------------------------------------------------
                            Example:       
                             /*ALTER TABLE employee
                               ADD (commission NUMBER DEFUALT 0 NOT NULL);
                               ------------------------------------------------------------------------------
                               ALTER TABLE employee
                               ADD (created_date DATE DEFUALT SYSDATE, created_by VARCHAR2(111) DEFUALT USER);*/          
                                _____________________________________________________________________________
                         _'MODIFY': 
                               -> Used to modify an existing column definition.   
                               -> Y can modify the 'datatype','size','defualt value' of the column.
                               -> A change to the defualt value does not affect the old data, it
                                  affects only subsequent insertions to the table.
                               -> Y can decrease the width of the coulumn only if:
                                           the column contains only NULL values, the table has no rows,
                                           the decrease in the column width is less than the existing
                                           values in that column.
                               -> Y can change the 'datatype' if the columns contains only NULL values.
                               Syntax:
                                     'ALTER  TABLE table_name 
                                      MODIFY col_name1 DATATYPE, col_name2 DATATYPE(SIZE) DEFUALT expr, ...;'
                                ___________________________________________________________________________  
                         _'RENAME':
                               -> It is used to rename the object(table,view).
                               -> It is used to rename a column in the table.
                               -> It is used to rename a constraint in the column.
                               Syntax:
                                     'RENAME old_obj_name TO new_obj_name;'
                                      ------------------------------------------ 
                                     'ALTER  TABLE  table_name
                                      RENAME COLUMN old_col_name TO new_col_name;'
                                      ------------------------------------------
                                     'ALTER  TABLE  table_name
                                      RENAME CONSTAINT old_const_name TO new_const_name;'
                                ___________________________________________________________________________   
                         _'CHANGE':
                               -> Used to change the name and datatype of a column.
                               Syntax:
                                     'ALTER  TABLE  table_name
                                      CHANGE old_col_name  new_col_name new_datatype;' 

                                     'ALTER  TABLE  table_name
                                      CHANGE old_col_name  new_col_name new_datatype AFTER col_name;'

                                     'ALTER  TABLE  table_name
                                      CHANGE old_col_name  new_col_name new_datatype ;'                          
                         _'DROP':    
                               -> The dropped column may or may not contain data.
                               -> The table must have at least one column remaining in it after is altered.
                               -> if the column is dropped, it cannot be recovered.
                               -> The Primariy Key that is referenced by another column cannot
                                  be dropped unless the 'Cascade CONSTRAINTS' is added.
                               -> Dropping a column can take a while if the column has a large number
                                  of values, y can use the 'Unused COLUMNS' and then drop it later.
                               Syntax: 
                                     'ALTER TABLE table_name 
                                      DROP  (col_name1 , col_name2, ...);'  //many table at a time.
                                      ----------------------------------------
                                     'ALTER TABLE table_name 
                                      DROP  Column col_name;'              //only one table at a time.

                                     'ALTER TABLE table_name 
                                      DROP  END;'

                                     'ALTER TABLE table_name 
                                      DROP  LAST;'
                                      ----------------------------------------
                                     'ALTER TABLE table_name 
                                      DROP COLUMN col_name CASCADE CONSTRANTS;'
                                      ----------------------------------------
                                     'ALTER TABLE table_name 
                                      DROP  UNUSED COLUMNS;'  
                               ___________________________________________________________________________     
                         _'UNUSED':
                               -> It is used to mark one or more columns as unused.
                               -> The unused column are logically not present,
                                  but it is sill present physically.
                               -> Y can specify 'ONLINE' keyword to indicate that 'DML' operations 
                                  on the table will be allowed while marking the column unused.
                               -> Y can add a new column has the same name of the unsed column.    
                               Syntax:   
                                     'ALTER TABLE table_name 
                                      SET   UNUSED col_name1, col_name2, ..., ...;'//many table at a time.            
                                     ----------------------------------------------
                                     'ALTER TABLE table_name 
                                      SET   UNUSED COLUMN col_name;'             //only one table at a time.
                                     ---------------------------------------
                                     'ALTER TABLE table_name 
                                      SET   UNUSED COLUMN col_name ONLINE;'              
                                ___________________________________________________________________________
                         _'READ ONLY' / 'READ WRITE;':
                               -> READ ONLY is used to prevent DDL OR DML changes during table mentainace.
                               -> Y should put the table back ino READ/WRITE mode.    
                               Syntax:
                                     'ALTER TABLE table_name READ ONLY;
                                              /*  ...  */
                                      ALTER TABLE table_name READ WRITE;'       
                                 ___________________________________________________________________________
                         _'ADD CONSTRAINT':
                               -> It is used to add new constraint to a column.
                               Syntax:
                                     "ALTER TABLE table_name
                                      ADD   CONSTRAINT const_name const_type (col_name);" 
                                 ___________________________________________________________________________         
                         _'DISABLE CONSTRAINT':
                               Syntax:
                                     "ALTER   TABLE table_name
                                      DISABLE CONSTRAINT const_name;" 
                                 ___________________________________________________________________________ 
                         _'ENABLE CONSTRAINT':
                               Syntax:
                                     "ALTER  TABLE table_name 
                                      ENABLE CONSTRAINT const_name;" 
                                 ___________________________________________________________________________    
                         _'DROP CONSTRAINT':
                               Syntax:
                                     "ALTER TABLE table_name 
                                      DROP  CONSTRAINT const_name;" 
                                 ___________________________________________________________________________            
            
            _"ALTER SESSION":
                  Guidlines: 
                         -> 
                  Syntax:
                         "ALTER SESSION SET time_zone;"  
            _"Drop Table":
                  Guidlines:
                         -> It is used to move the table to the 'Recycle Bin'.
                         -> It removes table and all its data entirely if 'PURGE' cluase is used.
                         -> Y cannot 'ROLLBACK' a dropped table with the  'PURGE' cluase.
                         -> Use 'PURGE' cluase to immediately release the space allocated to the table.
                         -> It invalidates dependent objects and removes object privileges on the table.
                         -> When y drop table, DB loses all data in table, all indexes assosiated with it. 
                         -> Any 'Views' and 'Synonyms' remain, but are invalid.
                         -> Any 'Pending Transactions' are commited.
                         -> Only two users can remove the table:
                                           1.The creator of the table.
                                           2.A user has the 'Drop Any Table' Privilege.
                         -> Use the 'FLASHBACK TABLE' to restore a dropped table from the 'Recycle Bin'.                   
                  Syntax:
                         __________________________________________________________
                         DROP TABLE table_name;
                         ----------------------
                         DROP TABLE table_name PURGE;
                         ----------------------------
                         'FLASHBACK TABLE table_name TO BEFORE DROP;'
                         "FLASHBACK TABLE table_name TO TIMESTAMP(SYSTIMESTAMP - INTERVAL '1' minute);"
                         ______________________________________________________________________________
            _"Truncate Table":
                  Guidlines:
                         -> It removes all rows from a table, leaving the table empty.
                         -> It leaves the table structure intact.
                         -> It is more faster than using 'Delete'.
                         -> 'RollBack' does not work with 'Truncate'.
                         -> If the table is Parent of a Referential Integrity Constraint,
                            you can not 'Truncate' the table, Y need to disable the constrait.
                         -> Y can not fire the 'Triggers'.   
                         -> It recovers space.
                  Syntax:
                         /*-------------------------
                         Truncate Table table_name;
                         ---------------------------*/
                  Example:
                         "--------------------------
                         Truncate Table employee;
                         ---------------------------"
            _"PURGE":
                     -> It is considered a DDL.
                     -> It is used to entirely remove table and all its data.
                     -> Y cannot 'ROLLBACK' a dropped table with the  'PURGE' cluase.
                     -> It immediately releases the space allocated to the table.
                     -> 'PURGE RECYCLEBIN' : used to clear the recyclebin.
                     Syntax: 
                            ------------------------------
                            'DROP TABLE table_name PURGE;'

                            'PURGE RECYCLEBIN;'
                            ------------------------------
            _"FLASHBACK TABLE":
                     -> It is considered a DDL.
                     -> It restore a dropped table from the 'Recycle Bin'.
                     ->                        
                     Syntax:
                            ------------------------------------------------------------------------------ 
                            'FLASHBACK TABLE table_name TO BEFORE DROP;'

                            "FLASHBACK TABLE table_name TO TIMESTAMP(SYSTIMESTAMP - INTERVAL '1' minute);" 
                            ------------------------------------------------------------------------------              
            _"Comment ON Table":
                  Guidlines:
                         -> It is used  to add comment on a table or column.
                         -> To query about the comment on table  use 'USER_TAB_COMMENTS'.
                         -> To query about the comment on column use 'USER_COL_COMMENTS'.
                  Syntax:
                         /*------------------------------------
                           Comment ON TABLE table_name
                           IS 'your comment';
                           ------------------------------------
                           Comment ON COLUMN table_name.col_name
                           IS 'your comment';
                           ------------------------------------
                           Select * From USER_TAB_COMMENTS
                           Where TABLE_NAME = 'table_name'.
                           ------------------------------------
                           Select * From USER_COL_COMMENTS
                           Where TABLE_NAME = 'table_name'.
                           ------------------------------------*/
                  Example:
                         "----------------------------------------" 
       2_DML:
           -> https://dev.mysql.com/doc/refman/8.3/en/sql-data-manipulation-statements.html 
           _"Insert":
                  Guidlines:
                         -> It is used to add only new one row to a table.
                         -> If y dont determine columns name, you should know order of columns.
                         -> If y dont determine ALL columns, values of undetermined cols will be NULL.
                         -> Y can add NULL explixitly to the undetermined columns.
                         -> Y must know that undetermined columns must accept NULL values.
                         -> Y can use 'special values or functions' in the 'Values Parentheses'.
                         -> Y can use &ampersand for prompt and creating a script.
                         -> Y can copy rows from another table using a subquery, do not use"Values Cluase".
                         -> Y must match number and datatype of cols in "Insert Into" to those in "SubQuery".
                         -> Using "Values cluase" to add only one row/record.
                         -> You can insert multiple row at a time.
                         -> Using "SubQuery"      to add multiple rows/records.
                         -> 'Multiple Insert':
                                   -> Inserting rows in multiple tables in on insert statement.
                                   -> It is used in data warehousing systems to transfer data 
                                      from one or more operational sources to a set of target tables.
                                   -> It provides significant performance improvement.
                                   -> It is performed only in tables, not views.
                                   -> Types of Multiple Insert are :   
                                           1.Unconditional INSERT:
                                                 -> For each row retuned by the subquery, a row is 
                                                    inserted into each of the target tables. 
                                                 Syntax:
                                                      "INSERT ALL
                                                       INTO table1(col1,col2,col3) VALUES(val1,val2,val3)
                                                       INTO table2(col1,col2,col3) VALUES(val1,val2,val3)
                                                       SELECT col1, col2, col3, col4
                                                       FROM   table3
                                                       WHERE  table3.col = 12;"    
                                           2.Conditional INSERT ALL:
                                                 -> For each row retuned by the subquery, a row is 
                                                    inserted into each target table if the specified 
                                                    condition is met.
                                                 Syntax:
                                                      "INSERT ALL
                                                       WHEN cond1_expr THEN 
                                                       INTO table1(col1,col2,col3) VALUES(val1,val2,val3)
                                                       WHEN cond2_expr THEN
                                                       INTO table2(col1,col2,col3) VALUES(val1,val2,val3)
                                                       SELECT col1, col2, col3, col4
                                                       FROM   table3;"      
                                           3.Conditional INSERT FIRST:
                                                 -> For each row retuned by the subquery, a row is 
                                                    inserted into the very first target table in which
                                                    the condition is met.
                                                 Syntax:
                                                      "INSERT FIRST
                                                       WHEN cond1_expr THEN 
                                                       INTO table1(col1,col2,col3) VALUES(val1,val2,val3)
                                                       WHEN cond2_expr THEN
                                                       INTO table2(col1,col2,col3) VALUES(val1,val2,val3)
                                                       SELECT col1, col2, col3, col4
                                                       FROM   table3;"     
                                           4.Pivoting INSERT:
                                                 -> It rotates a table-valued expression by turning
                                                    the unique values from one column in the expression 
                                                    into multiple columns in the output.
                  Syntax:
                         /*--------------------------------
                         Insert Into table(col1,col2,col3)
                         Values           (Val1,val2,val3);      //val1 may be seq.NEXTVAL if it is PK.
                         Commit;
                         ----------------------------------
                         Insert Into table(col2,col1,col3)
                         Values           (Val2,val1,val3);
                         ----------------------------------
                         Insert Into table
                         Values           (Val2,val1,val3); 
                         ----------------------------------
                         Insert Into table(col1,col2)             //col3 == NULL
                         Values           (Val1,val2,defualt);    //explicit defualt.
                         Commit;
                         -----------------------------------
                         Insert Into table(col1,col2)             //col3 == NULL
                         Values           (Val1,val2,NULL);
                         Commit;
                         ------------------------------------
                         Insert Into table(emp_id,col2)           //error as emp_id is a primary key.
                         Values           (NULL,val2,NULL);       //does not accept NULL values.
                         Commit;
                         ------------------------------------
                         Insert Into table(col1 ,col2 ,col3)      //for prompting           
                         Values           (&var1,&var2,&var3);
                         Commit;
                         ------------------------------------
                         Insert Into table(col2,col1,col3)       //multiple rows at a time.
                         Values           (Val2,val1,val3),
                                          (Val2,val1,val3),
                                          (Val2,val1,val3),
                                          (Val2,val1,val3);
                         -------------------------------------
                         Insert Into table1(col1, col2, col3)     //copying rows using a subquery.
                         Select             col1, col2, col3      //do not use "Values Cluase". 
                         From        table2;                
                         -------------------------------------
                         Insert Into table1                           //copying rows using a subquery.
                         Select *                                     //do not use "Values Cluase". 
                         From        table2;             
                         -------------------------------------*/
                  Example:
                        "----------------------------------------------- 
                         Insert Into department(dept_id,dept_name,loc_id)
                         Values                (122    , 'BA_END', 1666);
                         Commit;  

                         ----------------------------------------------------------
                         Insert Into department(dept_id,dept_name,dept_data,loc_id)
                         Values                (122    , 'BA_END', SYSDATE, 1666);
                         Commit;

                         Insert Into department(dept_id,dept_name,dept_data,loc_id)
                         Values          (122    , 'BA_END', to_date('20-05-2015','dd-mm-yyyy'), 1666);
                         Commit;     
                         -------------------------------------------------------------------------------
                         Insert Into table(dept_id, dept_name)      //for prompting           
                         Values           (&id    , '&name');
                         Commit;
                         -------------------------------------------------------------------------------"
           _"Update":
                  Guidlines:
                         -> It modifies existing values in a table.
                         -> Y can update one column at a time.
                         -> Y can update several columns at a time.
                         -> Y can set the column to NULL value.
                         -> It modifies more than one row at a time if required. 
                         -> Use the 'primary key col' in'Where cluase'to identify a single row.
                         -> Using other cols can cuase several rows to be updated.
                         -> If there is no 'Where Condition' the update will be for all the table.
                         -> Y can use 'SubQuery' in 'Update' statement.
                         -> Y can update a table based on another table, see the 'last Example'.
                  Syntax:
                         /*------------------------------------
                         Update  table_name
                         Set     col1 = new_value
                         Where   condition;
                         --------------------------------------------------
                         Update  table_name
                         Set     col1 = new_value, col2 = new_value, col3 = defualt,...   //explicit defualt
                         Where   condition;
                         ------------------------------------------------------------------------------*/
                     "Last Example":
                         Update table1
                         Set  col = 
                                 (Select col From table2 Where table2.emp_id = table1.emp_id)
                         //in this form the additional rows in table1 that does not meet the conditions
                           will be updated by NULL values when there is no 'Where cluase' in 
                           the condition this means all rows will be updated. 
                         ------------------------------------------------------------------------------        
                         Update table1
                         Set  col =  (Select col From table2 Where table2.emp_id = table1.emp_id)
                         Where Exists(Select 1   From table2 Where table2.emp_id = table1.emp_id) 
                         -----------------------------------------------------------------------------

                  Example:
                         "-------------------------------------------------
                         Update employee       | Update employee 
                         Set    salay = 3944   | Set    salay = defualt
                         Where  emp_id = 100;  | Where  emp_name = 'ahmed';     //can update several cols.
                         Commit;               | Commit;
                         ---------------------------------------------------
                         Update employee
                         Set    salay = 3944, dept_name = 'IT'
                         Where  emp_id = 100;
                         Commit;
                         ---------------------------------------------------
                         Update employee
                         Set    salay = 3944, dept_name = 'IT';
                         Commit;
                         ---------------------------------------------------
                         Update employee
                         Set    salay = NULL
                         Where  emp_id = 100;
                         Commit;
                         ---------------------------------------------------
                         Update employee
                         Set    salay = (Select salary From employee Where emp_id = 200)
                         Where  emp_id = 100;
                         Commit;
                         -----------------------------------------------------------------------
                         Update employee                          //this form is more efficient.
                         Set    (salay,dept_id) = 
                                       (Select salary, dept_id From employee Where emp_id = 200)
                         Where  emp_id = 100;
                         Commit;
                         -----------------------------------------------------------------------
                         Update employee
                         Set    salay    = (Select salary From employee Where emp_id = 200),
                                dept_id  = (Select dept_id From employee Where emp_id = 200)       
                         Where  emp_id = 100;
                         Commit;
                         ----------------------------------------------------------------------------
                     "Last Example":
                         Update copy_emp
                         Set  salary = 
                                 (Select salary From employee Where employee.emp_id = copy_emp.emp_id)

                         Update copy_emp
                         Set  salary = 
                                 (Select salary From employee Where employee.emp_id = copy_emp.emp_id)
                         Where Exists(Select 1  From employee Where employee.emp_id = copy_emp.emp_id) 
                         -----------------------------------------------------------------------------"                    

           _"Delete":
                  Guidlines:
                         -> It is used to remove existing rows from a table.
                         -> 'From' and 'Where' Cluases are optional.
                         -> If y do not use Where Cluase, all rows will be deleted.
                         -> If y del all rows from tab,tab will be empty but its structure is intact.
                         -> Y can 'RoollBack' the delete.
                         -> Y can delete based on 'SubQuery'.
                         -> Y can delete based on another table.
                         -> Becareful when you delete from table that has 'Referntial Constraints'.
                         -> Y must delete 'Dependencies' first than 'Parent'.
                         -> Y can fire the 'Triggers'.
                         -> It does not recover space.
                  Syntax:
                         /*---------------------
                         Delete From table_name       //note: 'From' and 'Where' are optional. 
                         Where  condition;
                         -----------------------
                         Delete table_name             
                         Where  condition;
                         -----------------------
                         Delete From table_name;      //note: all rows will be deleted.  
                         -----------------------
                         Delete table_name;           //note: all rows will be deleted.
                         ------------------------------------------------------------
                         Delete From table_name             
                         Where  column Operator 
                                     (SELECT column FROM table_name WHERE condition);
                         ------------------------------------------------------------*/
                  Example:
                         "--------------------
                         Delete From employee
                         Where  emp_id = 12;
                         ---------------------
                         Delete employee
                         Where  emp_id = 12;
                         ---------------------
                         Delete FROM employee;
                         ---------------------
                         Delete employee;;
                         ------------------------------------------------------------------------
                         Delete From employee             
                         Where  emp_id IN 
                                     (SELECT emp_id FROM employee WHERE emp_name LIKE '%ahmed%');
                         ------------------------------------------------------------------------
                         Delete From department d             
                         Where  NOT EXISTS  
                                     (SELECT 1 FROM employee e WHERE e.dept_id = d.dept_id);
                         ------------------------------------------------------------------------
                         Delete From employee        //to avoid Referntial Constraintviolation       

                         Delete From department
                         Where  dept_id = 90;
                         ------------------------------------------------------------------------"
           _"Merge" :
                  Guidlines:
                         -> It is used to perform DML operations in a table in the same time,
                            like insert, update, and delete.
                  Syntax:
                       /*--------------------------------------
                         MERGE INTO table1_name t1 //"table1_alias"
                         USING      table2_name t2 //"table2_alias"
                         ON    join_condition
                         WHEN MATCHED THEN 
                              UPDATE SET
                                     t1.col1_name = t2.col1_name,
                                     t1.col2_name = t2.col2_name
                         WHEN NOT MATCHED THEN
                              INSERT (column_list)
                              VALUES (column_values);  
                         --------------------------------------*/            
                  Example:
                         "----------------------------------------
                         MERGE INTO table1_name t1 //"table1_alias"
                         USING      table2_name t2 //"table2_alias"
                         ON    join_condition
                         WHEN MATCHED THEN 
                              UPDATE SET
                                     t1.first_name = t2.first_name,
                         WHEN NOT MATCHED THEN
                              INSERT (t1.id , t1.first_name)
                              VALUES (t2.id , t2.first_name);  
                         --------------------------------------"
       3_DCL:
           _"Grant":
                  Guidlines:
                         ->
                  Syntax:
                         /*--------------------------------------*/
                  Example:
                         "----------------------------------------"
           _"Revoke":
                  Guidlines:
                         ->
                  Syntax:
                         /*--------------------------------------*/
                  Example:
                         "----------------------------------------"        
       4_TCL:
             -> https://dev.mysql.com/doc/refman/8.3/en/sql-transactional-statements.html
              Guidlines:
                 -> A DataBase Transaction consists of one of the following that form a logical unit of work:
                          1.DML Statements(May be more than on DML Statements is cons a DB Transaction).
                          2.DDL Statement (Every DDL Statement is considered a DB Transaction).
                          3.DCL Statement (Every DDL Statement is considered a DB Transaction).
                 -> The Transaction begins when the first DML statement is excuted.
                 -> The Transaction ends with one of the following:
                          -> a 'Commit' or' RoolBack' statement is issued.
                          -> a DDL or DCL statement excutes(automatic Commit).
                          -> The User exisits SQL Developer.
                          -> The system crashes. 
                 -> With 'Commit' and 'RoolBack':
                          -> Y can ensure data consistency.
                          -> Y can preview data changes before making changes permenant.
                          -> Y can group logically related operations.
                 -> There are two types of TC Statements:
                          1.Explicit TC Statements: 
                                     -> "Commit".
                                     -> "RollBack".
                                     -> "SavePoint".
                                     -> "RollBack To SavePoint". 
                          2.implicit TC Statements:  
                                     -> Automatic Commit:   
                                                   A DDL or DCL statement excutes.
                                                   The User exisits SQL Developer 'normally'.
                                     -> Automatic RollBack: 
                                                   The User exisits SQL Developer 'abnormally'.
                                                   There is system failure.                                        
                 -> The Sate of data before 'Commit' or 'RollBack':
                          1.the previous state of the data can be recovered.
                          2.the current session can review the result of DML operations by 'SELECT'.
                          3.other sessions can not view results of DML issued by the current session.
                          4.affected rows are locked, other session can not change data in affected rows.
                 -> The Sate of data after 'Commit': 
                          1.data changes are saved in the database.
                          2.the previous state of the data is overwritten.
                          3.all sessions can view the results.
                          4.locks on the affected are released, those rows are available for all sessions.
                          5.all savepoints are erased.                    
              Types:    
                  _"Commit":
                          Def:
                              -> It ends current transaction by making all pending data changes permenant.
                              -> It saves data on the DataBase.
                              -> If y did DDL statement after DML, system will do commit automatically. 
                          Syntax:
                                 /*------------
                                 DML statements     
                                 Commit;                //explicit commit.
                                 --------------
                                 DML statements
                                 DDL statement          //implicit commit.   
                                 --------------*/
                          Example:
                                 "------------------------------------------
                                 Select emp_id, emp_name, salary, dept_name
                                 From   employee
                                 Where  emp_id = 100;
                                 
                                 Update employee
                                 Set    salay = 3944, dept_name = 'IT'
                                 Where  emp_id = 100;
                                 
                                 Commit;                                       //explicit commit.
                                 -------------------------------------------
                                 Select emp_id, emp_name, salary, dept_name
                                 From   employee
                                 Where  emp_id = 100;
                                 
                                 Update employee
                                 Set    salay = 3944, dept_name = 'IT'
                                 Where  emp_id = 100;
                                 
                                 Create Table as Select * From employee;       //implicit commit.
                                 -------------------------------------------"                             
                  _"RollBack":
                          Def:
                               -> It ends current transaction by discarding all pending data changes.\
                               -> note statement-level-rollback.
                  _"SavePoint":
                          Def:
                               -> It marks a savepoint within the current transaction.
                          Syntax:
                                 /*--------------------------------------
                                 SavePoint savepoint_name
                                 ----------------------------------------*/
                          Example:
                                 "------------------------------------------
                                 Select emp_id, emp_name, salary, dept_name
                                 From   employee
                                 Where  emp_id = 100;
                                 
                                 Update employee
                                 Set    salay = 3944, dept_name = 'IT'
                                 Where  emp_id = 100;
                                 
                                 SavePoint A;

                                 Select emp_id, emp_name, salary, dept_name
                                 From   employee
                                 Where  emp_id = 100;
                                 -------------------------------------------"
                  _"RollBack To SavePoint":
                          Def:
                               -> It rollback the current transaction to the specifies savepoint.
                               -> It discardes any changes or savepoints that were created after the it.
                          Syntax:
                                 /*--------------------------------------
                                 RollBack To SavePoint savepoint_name
                                 ---------------------------------------*/
                          Example:
                                 "------------------------------------------
                                 Select emp_id, emp_name, salary, dept_name
                                 From   employee
                                 Where  emp_id = 100;
                                 
                                 Update employee
                                 Set    salay = 3944, dept_name = 'IT'
                                 Where  emp_id = 100;
                                 
                                 SavePoint A;

                                 Select emp_id, emp_name, salary, dept_name
                                 From   employee
                                 Where  emp_id = 100;

                                 Update employee
                                 Set    salay = 3944, dept_name = 'IT'
                                 Where  emp_id = 100;

                                 RollBack To SavePoint A;

                                 Select emp_id, emp_name, salary, dept_name
                                 From   employee
                                 Where  emp_id = 100;
                                 -------------------------------------------"         
                  _"Set Transaction":
                          Def:
                               -> .
                          Syntax:
                                 /*--------------------------------------*/
                          Example:
                                 "----------------------------------------"                    
       5_Replication-Statements :
              -> https://dev.mysql.com/doc/refman/8.3/en/sql-replication-statements.html
       5_DQL:
            _"Select":
                  -> It is also considered as 'DML'.
                  -> "Projection-Selection-Join"
                  -> Select identifies the columns to be displayed.
                  -> From   identifies the table containing this columns.
                  Syntax: 
                       "Select * From table_name;
                        Select table_name.* From table_name;
                        Select col1_name, col2_name,...,.. From table_name;"       
                  
 _Sql Fuctions: 
              https://dev.mysql.com/doc/refman/8.3/en/string-functions.html
  1.Single Row Functions:
        Def:
            -> It returns one result per row.
            -> Single Row Functions can be used in "Select" "Where" "Order by".
            -> It can be nested to unlimited numbers.
            ________________________
           |                        |
           | a.Character  Functions.|          
           | b.Numeric    Functions.|
           | c.Date       Functions.|
           | d.Conversion Functions.|
           | e.General    Functions.|
           |________________________|

        Types:                       
            a.String Functions:
                  https://dev.mysql.com/doc/refman/8.3/en/string-functions.html
                  1.Case-Conversion Functions:
                         -> "LOWER"  : to convert string to lowercase. 
                         -> "UPPER"  : to convert string to uppercase.
                         -> "initcap": to convert the first char in the string to uppercase.
                         Forms: 
                                LOWER(str)  ==  LCASE(str). 
                                UPPER(str)  ==  UCASE(str). 
                                initcap('string' or col_name) : https://bugs.mysql.com/bug.php?id=57553

                       
                  2.Character-Manipulation Functions: "String Manipulation"
                                
                                LENGHT(str)
                                CHAR_LENGTH(str)
                                CHARACTER_LENGTH(str)

                                LEFT(str , length)
                                MID(str , pos , length)
                                RIGHT(str , length)

                                CONCAT(str1 , str2, str3 , ...).
                                CONCAT_WS(seterator , str1 , str2).

                                INSERT(str , pos , length , new_str).  



                                substr(col_name/string , start_pos , characters_long)
                                substr(col_name/string , start_pos)                     --to the end of the string.
                                substr(col_name/string , - start_pos , characters_long) --to start from the end.
                                substr(col_name/string , - start_pos)  

                                instr(str , 'the character' , start_searching_pos , occurrance)
                                instr(str , 'the character' , start_searching_pos ) 1
                                instr(str , 'the character' ) 1 , 1

                                Lpad(str , length , padded_str) 
                                Rpad(str , length , padded_str)
                                
                                REPLACE(str , 'replaced str' , 'the replacing str').
                                REPEAT (str , n).
                                REVERSE(str).
                                
                                TRIM(LEADING  'string_want_to_delete' FROM 'the whole_string') --from the start.
                                TRIM(TRAILING 'string_want_to_delete' FROM 'the whole_string') --from the end.
                                TRIM(BOTH     'string_want_to_delete' FROM 'the whole_string') --from both.
                                TRIM('string_want_to_delete' FROM 'the whole_string')          --from both.
                                TRIM('the whole_string')  -- it will delete space from both start and end.

                                LTRIM(str).
                                RTRIM(str).
                                
                         Example:  
                               'Select emp_id, Concat(first_name,last_name) as full_name
                                From employee;' 

                               'Select emp_id, first_name || ' ' || last_name) as full_name
                                From employee;'     
                                
                               'Select emp_id, 
                                first_name,
                                substr(first_name , 1 , 3),
                                substr(first_name , 2 ),
                                substr(first_name , -1 , 3),
                                substr(first_name , -1 )
                                From employee;'
                                
                               'Select first_name, length(first_name) as "length of f_name"
                                From employee;' 

                               "Select emp_id, 
                                first_name,
                                instr(first_name , 'e' , 1 , 2),
                                instr(first_name , 'e' , 2 ),
                                instr(first_name , 'e'),
                                From employee
                                Where first_name = 'nanette';"
                                
                               'Select emp_id, salary , lpad(salary , 10 , '#') , rpad(salary , 10 , '*')
                                From employee;' 

                               "Select emp_id, 
                                first_name,
                                replace(first_name , 'e'  , 'a'),
                                replace(first_name , 'a'  , '*'),
                                replace(first_name , '  ' , ' '),  -- two spaces by one space.
                                From employee;"
                                
                              "'Select trim(LEADING ' ' FROM '  Khaled  khadari  ') as col from dual;'
                               'Select trim(TRALING ' ' FROM '  Khaled  khadari  ') as col from dual;'
                               'Select trim(BOTH    ' ' FROM '  Khaled  khadari  ') as col from dual;'
                               'Select trim(        ' ' FROM '  Khaled  khadari  ') as col from dual;'
                               'Select trim(LEADING 'K' FROM 'Khaled  Khadari') as col from dual;'
                               'Select trim(TRALING 'K' FROM 'Khaled  Khadari') as col from dual;'
                               'Select trim(BOTH    'K' FROM 'Khaled  khadari') as col from dual;'
                               'Select trim(        'K' FROM 'Khaled  khadari') as col from dual;'
                               'Select trim('  Khaled  khadari  ') as col from dual;'"


            b.Numeric Functions:
                         -> "round": to
                         -> "trunc": to
                         -> "mod"  : to return the remainder of division.
                                     to know if the number 'even' or 'odd' by divided by '2',
                                     if 0 ->> even.
                                     else ->> odd.
                         Forms:
                                round(00.00)       //round(10.5) = 11           //round(10.46) = 10
                                round(00.00 , n)   //round(10.489 , 1) = 10.5   //round(10.499 , 2) = 10.5
                                                                                //round(10.493 , 2) = 10.49
                                round(00.00 , -n)  //round(55.493 , -1) = 60    //round(55.493 , -2) = 100
                                                   //round(555.493 , -2) = 600  //round(570.493 , -3) = 1000
                                                   //round(40.493 , -2) = 0     //round(465.493 , -3) = 0
                                                   //round(1470.493 , -2) = 1500

                                trunc(00.00)       //trunc(10.453) = 10
                                trunc(00.00 , n)   //trunc(10.853 , 2) = 10.85
                                trunc(00.00 , -n)  //trunc(998.6565 , -2) = 900 //trunc(9898.6565 , -2) = 9800
                                                   //trunc(9898.6565 , -4) = 0

                                mod(num1 , num2)   //mod(15 , 2) = 1        //mod(15 , 3) = 0
                                                   //mod(100 , 2) = 0       //mod(101 , 2) = 1                                 
                         Example:
                               "Select round(10.5) From Dual;
                                Select round(10.46) From Dual;
                                Select round(0.489 , 1) From Dual;
                                Select round(10.499 , 2) From Dual;
                                Select round(10.493 , 2) From Dual;
                                Select round(55.493 , -1) From Dual;
                                Select round(55.493 , -2) From Dual;
                                Select round(555.493 , -2) From Dual;
                                Select round(570.493 , -3) From Dual;
                                Select round(40.493 , -2) From Dual;
                                Select round(465.493 , -3) From Dual;
                                Select round(1470.493 , -2) From Dual;"

                               "Select trunc(10.453)  From Dual;
                                Select trunc(10.853 , 2) From Dual;
                                Select trunc(998.6565 , -2) From Dual;
                                Select trunc(9898.6565 , -2) From Dual;
                                Select trunc(9898.6565 , -4) From Dual;"

                               "Select mod(15 , 2)  From Dual;
                                Select mod(15 , 3)  From Dual;
                                Select mod(100 , 2) From Dual;
                                Select mod(101 , 2) From Dual;"                          
            c.Date Functions:
                         -> "to_char":
                         -> "to_date":
                         -> "INTERVAL":
                         Forms:
                                ()
                         Example:
                               ""
                         
            d.Conversion Functions:
                         -> "to_date"  : 
                         -> "to_char"  :
                         -> "to_number":
                         Forms:
                                to_date(char  , 'date_format_model')

                                to_char(date  , 'char_format_model')
                                to_char(number, 'char_format_model')
                                to_char(number)

                                to_number(char , 'number_format_model')
                                to_number(char)
                         Format Models:
                                 Date Format Model:
                                        Elements:
                                            -> 'YYYY' -->> Full year in numbers: '2015'
                                            -> 'YEAR' -->> Year spelled out in English:'Two Thousands and Fifteen'
                                            -> 'MM'   -->> Two digit value for the month:'12' '02'
                                            -> 'MONTH'-->> Full name of the month: 'FEBRUARY' 
                                            -> 'MON'  -->> Three letter abbreviation of the month: 'Feb' 
                                            -> 'DY'   -->> Three letter abbreviation of the day of the week.'' 
                                            -> 'DAY'  -->> Full name of the day of the week: 'MONDAY' 
                                            -> 'DD'   -->> Numeric day of the month: '03' '12' 
                                            
                                            -> 'AM'   or 'PM'   -->> Meridian indicator''
                                            -> 'A.M.' or 'P.M.' -->> Meridian indicator with periods: ''
                                            -> 'HH'   or 'HH12' -->> 12 hour format: ''
                                            -> 'HH24'           -->> 24 hour format: ''
                                            -> 'MI'    -->> Minute: ''
                                            -> 'SS'    -->> Second: ''
                                            -> 'SSSSS' -->> Second past midnight: ''
                                        The full models:
                                                     'DD-MON-YYYY HH'
                                                     ''
                                                     ''
                                                     ''
                                                     ''           
                                 Char Format Model:
                                            ->
                                            ->
                                            ->  
                                 Number Format Model:
                                        Elements:
                                            -> '9' -->> Represents a number: ''
                                            -> '0' -->> Forces a Zero to be displayed: ''
                                            -> '$' -->> Places a floating dolar sign: ''
                                            -> 'L' -->> Uses the floating local currency symbol: ''
                                            -> '.' -->> Prints a decimal point: ''
                                            -> ',' -->> Prints a comma as a Thousands indicator: '' 
                                            -> '/ . , - :' -->> Punctuation  is reproduced in the result: ''
                                            -> "of the"    -->> Quoted string is reproduced in the result: '' 
                                            -> 'TH'   -->> Ordinal number:    DDTH --> 4th
                                            -> 'SP'   -->> Spelled ou number: DDSP --> FOUR
                                            -> 'SPTH' or 'THSP' -->> DDSPTH --> FOURTH
                                                                     DDTHSP --> FOURTH
                                        The full models:
                                                     ''
                                                     ''
                                                     ''
                         Example:
                               ""
            e.General Functions:
                         -> It deals with NULL values.
                         "IFNULL()":
                         "COALESCE()":
                         -> "NVL": 
                         -> "NVL2":   
                         -> "nullif":       
                         -> "decode":
                         -> "case":
                         Forms:
                                NVL(expr1 , expr2)
                                                 -> to convert a NULL value to an acual value.
                                                 -> if expr1 == NULL, it returns expr2.
                                                 -> expr1 and expr2 should be the same Datatype.
                                                 // nvl(commission , 0)
                                                 // nvl(hire_date  , '01-JAN-96')
                                                 // nvl(job_id     , 'No Job Yet')
                                                 // nvl(to_char(commission) , 'no comm')
                                NVL2(expr1 , expr2 , expr3)
                                                 -> if expr1 is not NULL, it returns expr2.
                                                 -> if expr1 is     NULL, it returns expr3.
                                                 // nvl2(commission , commission , 0)
                                                 // nvl2(commission , 'sal and comm' , 'only salary') income
                                NULLIF(expr1 , expr2)
                                                 -> to compare two Expressions.
                                                 -> if they are     equal, it return NULL.
                                                 -> if they are not equal, it return the first Expression.
                                                 // nullif(length(first_name) , length(last_name)) results
                                COALESCE(expr1 , expr2 , expr3 , ... , ... , exprN)
                                                 -> to return the first not-NULL Expression in the Expression list.
                                                 -> equal to nested nvl.
                                                 // coalesce(col1 , col2 , col3 , coln)
                         Example:
                               "Select emp_id , first_name , commission , nvl(commission , 0)
                                From employee;

                                Select emp_id , first_name , hire_data , nvl(hire_data , '01-JAN-96')
                                From employee;

                                Select emp_id , first_name , job_id , nvl(job_id     , 'No Job Yet')
                                From employee;
                                
                                Select emp_id , first_name , commission , nvl(to_char(commission) , 'no comm')
                                From employee;"

                               "Select emp_id , first_name , commission , nvl2(commission , commission , 0)
                                From employee;  

                                Select emp_id , first_name , commission , (commission , 'sal and comm' , 'only salary') income
                                From employee;"

                               "Select first_name, length(first_name), last_name, length(last_name),
                                nullif(length(first_name) , length(last_name)) results
                                From employee;"

                               "Select emp_id, first_name, commission, manager_id, salary,
                                coalesce(commission , manager_id , salary) as coalescing
                                From employee;

                                Select emp_id, first_name, commission, manager_id, salary,
                                nvl1(nvl(commission , manager_id) , salary)
                                From employee;"
            f.Other Functions:
                           USER:
                           SYSDATE: 
                           INTERVAL:

  2.Multiple Row Functions:
        Def:
            -> It is also called "Group Functions"/"Aggregate Functions"
            -> It returns one result per set of rows.
            -> The group functions are palced in the 'SELECT' statement.
            -> Syntax :   group_function(DISTINCT/ALL expr/col). 
            -> 'DISTINCT' remove duplicate values.
            -> 'ALL' does not remove the duplicate values, 'ALL' is the defualt.
            -> all group functions ignore the NULL values.
            -> to subistitute a value for NULL, use the General Functions.
            -> they work with CHAR, VARCHAR2, NUMBER, DATE Datatypes.
            -> you can not use 'SUM' or 'AVG' with VARCHAR2 or DATE.
            -> in 'SELECT' statement you should use "Group by" cluase if you use
               group_function and columns, and you should put all columns after "Group by" cluase.
            -> "Where" cluase does not accept "Group Functions" after it, you can use "Having" cluase.
            -> Group Functions can be nested maximum of 2 functions.    
            _______________
           |               |
           |   1.AVG.      |          
           |   2.COUNT.    |
           |   3.MAX.      |
           |   4.MIN.      |
           |   5.SUM.      |
           |   6.LISTAGG.  |
           |   7.STDDEV.   |
           |   8.VARIANCE. |
           |_______________|

        Forms:
               group_function(DISTINCT/ALL expr/col) 
        Example:

              "Select max(salary) , min(salary)        //with number Datatype.
               From employee;

               Select max(first_name) , min(last_name) //with varchar2.
               From employee;

               Select max(hire_data) , min(hire_data)   //with date.
               From employee;"

              "Select SUM(salary) , AVG(salary)        
               From employee;" 

              "Select  COUNT(*) From employee;          //return the number of rows in the table including,
               Select  COUNT(1) From employee;          //duplicate and NULL values.

               Select  COUNT(dept_id) From employee;           //with    duplicates and without NULLs.
               Select  COUNT(ALL dept_id) From employee;       //with    duplicates and without NULLs.
               Select  COUNT(DISTINCT dept_id) From employee;  //without duplicates and without NULLs.
              
               Select  COUNT(NVL(dept_id , 0)) From employee;  //handling NULLs using NVL functions.

               Select  COUNT(emp_id)                          
               From employee
               Where dept_id = 90;"

              "Select LISTTAGG(first_name, ' - ') 
                     WITHIN GROUP(Order by first_name) as "Emp_list"
               From employee
               Where dept_id = 90;"       

              "Select dept_id , max(salary) , min(salary)        
               From employee;
               Groub by dept_id;

               Select dept_id , job_id , SUM(salary)        
               From employee;
               Groub by dept_id , job_id;
               
               Select dept_id , job_id , SUM(salary)        
               From employee;
               Groub by dept_id , job_id
               Order by 1,2;"

              "Select dept_id , MAX(SUM(salary))        
               From employee
               Groub by dept_id
               Order by 1;"
  3.Control Flow Functions: https://www.sqlshack.com/learn-mysql-control-flow-functions/ 
                 1.The IF functions : 
                         Syntax:
                            "IF(condition , if_true , if_false)"
                         Example:
                            "SELECT name , IF(salary > 1000 , 'high sal' , 'low sal')
                             FROM employee;"
                            "SELECT name , IF(salary > 1000 , CONCAT('high sal' , salary) , 'low sal')
                             FROM employee;"

                            "UPDATE emp SET salary = IF(salary < 1000 , salary + 500 , salary)
                             FROM employee;"    

                 2.The CASE function:
                            "------------------------------------------
                            CASE
                                 WHEN expression = value THEN result
                                 WHEN expression = value THEN result
                                 WHEN expression = value THEN result
                                 ELSE result
                            END
                            ------------------------------------------
                            CASE expression/col
                                 WHEN value THEN result 
                                 WHEN value THEN result
                                 WHEN value THEN result
                                 ELSE result
                            END
                            ------------------------------------------" 
                          Example:
                           "SELECT name ,
                            CASE
                                 WHEN salary < 1000 THEN 'low sal'
                                 WHEN salary > 1000 THEN 'high sal'
                                 ELSE 'no sal'
                            END as 'sal_grade'
                            FROM employee;"                 

                 3.The IFNULL function
                 4.The NULLIF function          
 
 _Joins:
         Def:
             -> Used to display or retrieve data from multiple tables.
             ->
             -> 
         Guidlines:
                      1.You should precede the col_name with the table_name for clarity and enhance database.
                      2.If the same col_name appears in more than one table, 
                        You should precede the col_name with the table_name.
                      3.Write the Join condition in the 'Where' cluase.
                      4.To join N tables together, you need a min of N-1 'Join Condition'.
                      5.If you do not use 'Join Condition' in 'SELECT', the result will be"Cartizian Product".
         General Syntax:
                'Select table1.col_name , table2.col_name
                 From   table1 , table2
                 Where  table1.col_name1 = table2.col_name2;'      //the join condition. 
         Types:
                 -> There are 2 verion types of "join types" : Old Version , New Version. 
                   ---------------------------------------------------------------------------------------
                  | #Old Version :                           #New Version :                               |
                  |   1.Cartizian Product.                   | 1.Cross Joins.                             |
                  |   2.Equijoin.                            | 2.Natural Joins.                           |
                  |   3.NonEquijion.                         | 3."Join..Using.."Cluase.                   |
                  |   4.Self join.                           | 4."Join..On.."Cluase.                      |       |
                  |   5.Outer join.                          | 5.Outer Joins.                             |
                  -----------------------------------------------------------------------------------------
              #Old Version :
                      1."Cartizian Product":
                                 -> It is equal to 'Cross Join'.
                                 ->
                                 Syntax:
                                        -------------------------------------
                                        "Select table1.column, table2.column
                                         From   table1 , table2;"
                                        -------------------------------------
                                 Example:  
                                        "Select first_name, dept_name
                                         From   employee, department;"
                      2."EquiJoin":
                                 -> Equal to "Inner Joins"/"Natural Joins"/"Simple Joins"/"Using"/"ON".
                                 -> Used to join 2 tables,one of them have foreign key  
                                    that references to the primary key in the other table.
                                 -> If any part in 'join condition' has NULL value, 
                                    the data of the NULL record will not retrieved.   
                                 Syntax:
                                       ----------------------------------------- 
                                       "Select table1.col_name , table2.col_name
                                        From   table1 , table2
                                        Where  table1.column = table2.column;"
                                       ----------------------------------------- 
                                 Example:
                                       "Select   employee.emp_id,
                                                 employee.first_name,
                                                 employee.dept_id,
                                                 department.dept_name,
                                        From     employee , department 
                                        Where    employee.dept_id = department.depart_id;"

                                       "Select   employee.emp_id,
                                                 employee.first_name,
                                                 employee.dept_id,
                                                 department.dept_name,
                                        From     employee , department 
                                        Where    employee.dept_id = department.depart_id;
                                        And      employee.dept_id > 40
                                        Order by employee.emp_id;"

                                       "Select   Emp.emp_id,
                                                 Emp.first_name,
                                                 Emp.dept_id,
                                                 Dept.dept_name,
                                        From     employee as Emp,
                                                 department  Dept 
                                        Where    Emp.dept_id = Dept.depart_id
                                        And      Empe.dept_id > 40
                                        Order by Emp.emp_id;"

                                       "Select   e.emp_id,
                                                 e.first_name,
                                                 e.dept_id,
                                                 d.dept_name,
                                                 d.loc_id,
                                                 L.country,
                                                 L.city
                                        From     employee as e,
                                         department  d,
                                         location as "L"    
                                        Where    e.dept_id = d.depart_id
                                        And      d.loc_id  = L.locat_id
                                        Order by e.emp_id; " 
                      3."NonEquiJion":
                                 -> It is a 'Join Condition' containing something
                                    other than an equality Operator"=".
                                 -> 
                                 Example:
                                       "Select Emp.first_name,
                                               Emp.salary,
                                               J_G.grade_level
                                        From   employee Emp, job_grade J_G
                                        Where  Emp.salary BETWEEN J_G.lowest_sal AND J_G.highest_sal;"

                                       "Select Emp.first_name,
                                               Emp.salary,
                                               J_G.grade_level
                                        From   employee Emp, job_grade J_G
                                        Where  Emp.salary >= J_G.lowest_sal 
                                        AND    Emp.salary <= J_G.highest_sal;"

                      4."Self Join":
                                 -> Used to join a table with itself.   
                                 -> You can perform 'Self Join' using table aliases.
                                 -> The table aliases allow us not to use the same table name
                                    twice with a single statement. 
                                 -> If we use the same table name more than one time
                                    in a single query without table aliases,it will throw an error.
                                    
                                 Syntax:
                                       ---------------------------------
                                       Select T1.col_name, 
                                              T2.col_name
                                       From   table1 as T1, table1 as T2
                                       Where  T1.column = T2.column;
                                       ---------------------------------  
                                 Example:
                                      "Select worker.emp_id,
                                              worker.first_name,
                                              worker.manger_id,
                                              manager.first_name
                                       From   employee worker,
                                              employee manager 
                                       Where  worker.manger_id = manager.emp_id;"

                                      "Select worker.emp_id,
                                              worker.first_name,
                                              worker.manger_id,
                                              manager.first_name
                                       From   employee worker,
                                              employee manager 
                                       Where  worker.manger_id = manager.emp_id(+);" 
                      5."Outer Join":
                                 -> the Outer Join Operator is the 'Plus Sign (+)'.
                                 -> The 'Plus Sign (+)' is placed in the defected part. 
                                 -> there are to types : right outer join  , left outer join.
                                 Syntax:
                                       ------------------------------------------ 
                                      "Select table1.col_name , table2.col_name
                                       From   table1 , table2
                                       Where  table1.column    = table2.colum(+);"    //Left Outer Join.
                                       ------------------------------------------          
                                      "Select table1.col_name , table2.col_name
                                       From   table1 , table2
                                       Where  table1.column(+) = table2.colum;"       //right Outer Join.
                                       -------------------------------------------                                
                     
                                 Example:
                                      "Select   employee.emp_id,
                                                employee.first_name,
                                                employee.dept_id,
                                                department.dept_name,
                                       From     employee , department 
                                       Where    employee.dept_id = department.depart_id(+) 
                                       Order by employee.emp_id;"

                                      "Select   employee.emp_id,
                                                employee.first_name,
                                                employee.dept_id,
                                                department.dept_name,
                                       From     employee , department 
                                       Where    employee.dept_id(+) = department.depart_id 
                                       Order by employee.emp_id;"  
                                      -------------------------
                                      "the big example in video number 31 khalid alkhodari"
              #New Version :
                      1."Cross Join":
                                 -> It returns the Cartesian Product from the two tables.
                                 -> 
                                 Syntax:
                                        -------------------------------------
                                        "Select table1.column, table2.column
                                         From   table1
                                         Cross  Join table2;"
                                        -------------------------------------   
                                 Example:
                                        "Select e.emp_id, e.first_name, d.dept_name
                                         From   employee e
                                         Cross  Join department d
                                         Order  by emp_id;" 
                      2."Natural Join":
                                 -> It joins two tables based on the same col_name.
                                 -> The two tables must have at least one column,
                                    that has the 'same name' and 'same datatype'.
                                 -> the column used in 'Natural Join' can not prefix by table name.   
                                 Syntax:
                                        -------------------------------------
                                        "Select  table1.column, table2.column, shared_column
                                         From    table1
                                         Natural Join table2;"    //note: shared_column can not be prefixed.
                                        ------------------------------------- 
                                 Example: 
                                        "Select  d.dept_id, d.dept_name, loc_id, L.city 
                                         From    department d                          
                                         Natural Join location L;"       //note: loc_id can not be prefixed.
                      3."Join..Using..":
                                 -> It performs EquiJoin based on the column name presented in the two tables. 
                                 -> The two tables must have at least one column,
                                    that has 'the same name' and 'same or different datatype'.
                                 -> Do not use a table_name or alias in the referenced column.
                                 -> the column used in 'Using' can not prefix by table name.     
                                 Syntax:
                                        -------------------------------------
                                        "Select  table1.column, table2.column
                                         From    table1
                                         Join    table2 
                                         Using   (refernced_column_name);"    //can not prefix by table name.
                                        -------------------------------------
                                 Example:
                                        "Select e.emp_id, e.first_name, d.loc_id
                                         From   employee e
                                         Join   department d
                                         Using  dept_id;"
                      4."Join..On..":
                                 -> It is the most important Join Type.
                                 -> It performs EquiJoin based on the condition in the 'ON' cluase. 
                                 -> It is used to specify arbitrary conditions or specify columns to join.
                                 -> The join can be Two Way Join or Three Way Join.
                                 -> the column used as reference must be prefixed by table name in 'SELECT'.
                                 -> It can be used as 'EquiJoin'/'NonEquiJoin'/'Self Join'.
                                 Syntax:
                                        ----------------------------------------------------
                                        "Select  table1.column, table2.column, ref_col_name    //as EquiJoin.
                                         From    table1   
                                         Join    table2 
                                         ON    ( table1.ref_col_name = table2.ref_col_name );"
                                        -----------------------------------------------------
                                        "Select  table1.column, table2.column, table3.column   //as EquiJoin.
                                         From    table1
                                         Join    table2 
                                         ON    ( table1.ref_col_name = table2.ref_col_name )
                                         Join    table3 
                                         ON    ( table2.ref_col_name = table3.ref_col_name );"
                                        ------------------------------------------------------
                                 Example:
                                    //as EquiJoin:
                                        "Select  e.emp_id, e.first_name, d.dept_id, d.dept_name
                                         From    employee e
                                         Join    department d 
                                         ON    ( e.dept_id = d.dept_id );"

                                        "Select  e.emp_id, e.first_name, d.dept_id, d.dept_name, L.city
                                         From    employee e
                                         Join    department d 
                                         ON      e.dept_id = d.dept_id
                                         Join    location L
                                         ON      d.loc_id = L.loc_id;"
                                    //as NonEquiJoin: 
                                        "Select Emp.first_name,
                                                Emp.salary,
                                                J_G.grade_level
                                         From   employee Emp
                                         Join   job_grade J_G
                                         ON     Emp.salary BETWEEN J_G.lowest_sal AND J_G.highest_sal;"

                                        "Select Emp.first_name,
                                                Emp.salary,
                                                J_G.grade_level
                                         From   employee Emp
                                         Join   job_grade J_G
                                         ON     Emp.salary >= J_G.lowest_sal 
                                         AND    Emp.salary <= J_G.highest_sal;" 
                                    //as Self Join:
                                        "Select worker.emp_id,
                                                worker.first_name,
                                                worker.manger_id,
                                                manager.first_name
                                         From   employee worker
                                         Join   employee manager 
                                         ON     worker.manger_id = manager.emp_id;"

                                        "Select worker.emp_id,
                                                worker.first_name,
                                                worker.manger_id,
                                                manager.first_name
                                         From   employee worker
                                         Join   employee manager 
                                         ON     worker.manger_id = manager.emp_id(+);"                                           
                                             
                      5."Outer Join":
                                 -> There are 3 types : 'Left / Right / Full Outer Join'.
                                 ->   
                                 Syntax:
                                        ------------------------------------------------
                                        "Select     table1.column, table2.column         //left outer join  
                                         From       boss_table1
                                         Left Outer Join table2 
                                         ON         table1.col_name = table2.col_name;"  //join condition.
                                        -----------------------------------------------
                                        "Select      table1.column, table2.column        //right outer join
                                         From        table1
                                         Right Outer Join boss_table2 
                                         ON          table1.col_name = table2.col_name;"  //join condition.
                                        -----------------------------------------------
                                        "Select      table1.column, table2.column         //full outer join
                                         From        boss_table1
                                         Full Outer  Join boss_table2 
                                         ON          table1.col_name = table2.col_name;"  //join condition.
                                        ------------------------------------------------
                                 Example:
                                        "Select     e.emp_id, e.first_name, e.dept_id, d.dept_name   
                                         From       employee e
                                         Left Outer Join department d
                                         ON         e.dept_id = d.dept_id         //left outer join.
                                         Order by   emp_id;"

                                        "Select      e.emp_id, e.first_name, e.dept_id, d.dept_name   
                                         From        employee e
                                         right Outer Join department d            //right outer join. 
                                         ON          e.dept_id = d.dept_id
                                         Order by    emp_id;"

                                        "Select      e.emp_id, e.first_name, e.dept_id, d.dept_name   
                                         From        employee e
                                         Full Outer  Join department d            //full outer join
                                         ON          e.dept_id = d.dept_id
                                         Order by    emp_id;"

                      6."Delete..Join":
                      7."Inner Join":                     

 _SubQuery:
             Guidlines:
                   -> It is also called 'Inner Query'.
                   -> The SubQuery executes before the Main Query'Outer Query'.
                   -> The result of the subquery is used by the main query.
                   -> Enclose subqueries in parentheses.
                   -> Place subqueries on the right side of the comparision condition.
                   -> Use 'Single-Row-Operators'   with 'Single-Row-Subqueries'.
                   -> Use 'Multiple-Row-Operators' with 'Multiple-Row-Subqueries'.
                   -> If subquery returns NULL then the main query will return NULL.
                   -> Do not use 'NOT IN' when SubQuery returns some NULL values.
                   -> Always use table_alias in 'EXIST/NOT EXIST'.    
                   -> Y can use SubQueries to manipulate data (DML). 
                   -> Correlated SubQuery:https://www.geeksforgeeks.org/sql-correlated-subqueries/.     
             Types: 
                   1.Single-Row-SubQuery:
                             -> It returns single row only.
                             -> Used with 'Single-Row/Value-Comparison-Operators'"SRCO": = > >= < <= <> !=
                   2.Multiple-Row-SubQuery:
                             -> It returns multiple rows.
                             -> Used with 'Multiple-Row/Value-Comparison-Operators'"MRCO": IN  ANY  ALL
                             -> Used with 'EXISTS/NOT EXISTS'.
                   3.Multiple-Column-SubQuery:
                   4.Source-Table-SubQuery:
                   5.Pairwise-Comparison-SubQuery:
                   6.Non-Pairwise-Comparison-SubQuery:
                   7.Scalar-SubQuery:
                             -> It is a subquery that retruns one column value from one row.
                             -> It used when you need to return one column from another table,
                                instead of using 'JOINS'. 
                   8.Correlated-SubQuery:
                   9.Joining-SubQueries:
                   10.SubQueries and UNIONs:
                   11.EXIST/NOT EXIST:
                   12.WITH cluase:
                   13.Inserting using SubQuery.
                   14.Updating  using SubQuery.
                   15.Deleting  using SubQuery.
                   16.Correlated-SubQuery:

             Syntax:
                  Single-Row-SubQuery:
                     "Select select_list
                      From   table_name
                      Where  col_name SRCO
                                    (Select statement);"
                      ----------------------------------
                  Multiple-Row-SubQuery:
                     "Select select_list
                      From   table_name
                      Where  col_name MRCO
                                    (Select statement);"
                      ---------------------------------- 
                  Multiple-Column-SubQuery: 
                  Source-Table-SubQuery:      
                  Pairwise-Comparison-SubQuery:
                     "Select select_list
                      From   table_name
                      Where  (col1, col2) IN
                                    (Select col1, col2 
                                     FROM   table_name WHERE col_name = ? );"
                      -------------------------------------------------------    
                  Non-Pairwise-Comparison-SubQuery:
                     "Select select_list
                      From   table_name
                      Where  col1 IN
                                    (Select col1
                                     FROM   table_name WHERE col_name = ? );
                      AND    col2 IN
                                    (Select col2
                                     FROM   table_name WHERE col_name = ? );"        
                      -------------------------------------------------------
                  Scalar-SubQuery:
                     'SELECT emp_id, first_name, dept_id
                            (SELECT dept_name FROM department d WHERE e.depart_id = d.depart_id) as dept_name
                      FROM   employee e;'
                      -------------------------------------------------------------------------------------------------
                     'SELECT emp_id, first_name, dept_id
                      NVL((SELECT dept_name FROM department d WHERE e.depart_id = d.depart_id), 'no dept') as dept_name
                      FROM   employee e;'
                      -------------------------------------------------------------------------------------------------       
                  Correlated-SubQuery:  
                  Joining-SubQueries: 
                  SubQueries and UNIONs:  
                  EXIST/NOT EXIST:  
                     //Retrieve all department information that have employee:
                     "Select * 
                      From   department d
                      Where  EXISTS( Select dept_id From employee e Where e.dept_id = d.dept_id );"
                     //Retrieve all department information that have no employee:
                     "Select * 
                      From   department d
                      Where  NOT EXISTS( Select dept_id From employee e Where  e.dept_id = d.dept_id );"
                      ----------------------------------------------------------------------------------
                  WITH cluase: 
                  Inserting using SubQuery:
                      ----------------------------------- 
                     "INSERT INTO 
                      ( 
                            SELECT dept_id, dept_name            as a table
                            FROM   department
                            WHERE  dept_id = 12
                      )
                      VALUES  (111, 'IT');"
                      -----------------------------------
                  Updating  using SubQuery:
                      ----------------------------------- 
                     "UPDATE
                      ( 
                            SELECT emp_id, emp_name, salary
                            FROM   employee
                            WHERE  dept_id = 12
                      )
                      SET   salary = salary + 100;"
                      -------------------------------------------------------------------
                     "UPDATE employee2 e2             //for equal records in both tables.
                      SET (select Salary FROM employee1 e1 WHERE e1.emp_id = e2.emp_id);" 
                      -------------------------------------------------------------------
                      "UPDATE employee2 e2             //for Unequal records in both tables.
                      SET (select Salary FROM employee1 e1 WHERE e1.emp_id = e2.emp_id)
                      WHERE EXISTS (select 1 FROM employee1 e1 WHERE e1.emp_id = e2.emp_id);" 
                      -------------------------------------------------------------------
                  Deleting  using SubQuery: 
                      -------------------------------------------------------------------
                     "DELETE FROM employee2 e2             
                      WHERE EXISTS (select 1 FROM employee1 e1 WHERE e1.emp_id = e2.emp_id);" 
                      -------------------------------------------------------------------
             Example: 
                -> Single Row Subqueries:
                     "Select first_name, salary
                      From   employee
                      Where  salary >
                                    (Select salary
                                     From   employee
                                     Where  first_name = 'Adel');"
                     ---------------------------------------------
                     "Select first_name, job_id, salary
                      From   employee
                      Where  job_id =
                                    (Select job_id
                                     From   employee
                                     Where  first_name = 'Adel')
                      AND    salary >
                                     (Select salary
                                     From   employee
                                     Where  first_name = 'Adel');"                
                     ----------------------------------------------
                     "Select first_name, salary
                      From   employee
                      Where  salary =
                                    (Select MIN(salary)
                                     From   employee  );"
                     ----------------------------------------------
                     "Select first_name, dept_id,MIN(salary)
                      From     employee
                      Groub by dept_id
                      Having   MIN(salary) >
                                           (Select MIN(salary)        //MIN(salary) returns single row.
                                            From   employee           //you can not write salary without MIN.
                                            Where  dept_id = 50);"
                     ----------------------------------------------                       
                -> Multiple Row Subqueries:
                     "Select first_name, salary
                      From   employee
                      Where  salary IN                       //NOT IN can be used.
                                     ( Select salary
                                       From   employee
                                       Where  dept_id = 90 );"
                     ------------------------------------------
                     "Select first_name, salary
                      From   employee
                      Where  salary >= Any                   //NOT Any can be used.    
                                     ( Select salary
                                       From   employee
                                       Where  dept_id = 90 );"
                     ------------------------------------------
                     "Select first_name, salary
                      From   employee
                      Where  salary >= ALL                   //NOT ALL can be used.
                                     ( Select salary
                                       From   employee
                                       Where  dept_id = 90 );"
                     ------------------------------------------
                    //Do not use 'NOT IN' when SubQuery return some NULL values.
                     "Select first_name, salary
                      From   employee
                      Where  emp_id IN  ( Select manager_id  From   employee );"   //no error.
                      ------------------------------------------------------------------------
                      "Select first_name, salary
                      From   employee
                      Where  emp_id NOT IN  ( Select manager_id  From   employee );"   // error.
                     ---------------------------------------------------------------------------
                     //Retrieve all department information that have employee:
                     "Select * 
                      From   department d
                      Where  EXISTS( Select dept_id From employee e Where e.dept_id = d.dept_id );"
                     //Retrieve all department information that have no employee:
                     "Select * 
                      From   department d
                      Where  NOT EXISTS( Select dept_id From employee e Where  e.dept_id = d.dept_id );"
                      ----------------------------------------------------------------------------------              
 _Transaction:
       Def:
         -> A DataBase Transaction consists of one of the following that form a logical unit of work:
                          1.DML Statements(May be more than on DML Statements is cons a DB Transaction).
                          2.DDL Statement (Every DDL Statement is considered a DB Transaction).
                          3.DCL Statement (Every DDL Statement is considered a DB Transaction).
         -> The Transaction begins when the first DML statement is excuted.
         -> Types : "autonomous transactions"
         -> The Transaction ends with one of the following:
                          -> a 'Commit' or' RoolBack' statement is issued.
                          -> a DDL or DCL statement excutes(automatic Commit).
                          -> The User exisits SQL Developer.
                          -> The system crashes.  
         -> With 'Commit' and 'RoolBack':
                          -> Y can ensure data consistency.
                          -> Y can preview data changes before making changes permenant.
                          -> Y can group logically related operations.
         -> There are two types of TC Statements:
                          1.Explicit TC Statements: 
                                     -> "Commit".
                                     -> "RollBack".
                                     -> "SavePoint pointName".
                                     -> "RollBack To SavePoint pointName". 
                                     -> "RELEASE SAVEPOINT pointName". 
                          1.implicit TC Statements:  
                                     -> Automatic Commit:   
                                                   A DDL or DCL statement excutes.
                                                   The User exisits SQL Developer 'normally'.
                                     -> Automatic RollBack: 
                                                   The User exisits SQL Developer 'abnormally'.
                                                   There is system failure.                                        
         -> The Sate of data before 'Commit' or 'RollBack':
                          1.the previous state of the data can be recovered.
                          2.the current session can review the result of DML operations by 'SELECT'.
                          3.other sessions can not view results of DML issued by the current session.
                          4.affected rows are locked, other session can not change data in affected rows.
         -> The Sate of data after 'Commit': 
                          1.data changes are saved in the database.
                          2.the previous state of the data is overwritten.
                          3.all sessions can view the results.
                          4.locks on the affected are released, those rows are available for all sessions.
                          5.all savepoints are erased.
       Example:
                "----------------------------------------
                Insert Into employee(emp_id, emp_name)
                Values              (122, 'ahmed');
                -----------------------------------------
                Create Table employee AS Select From EMP;
                -----------------------------------------
                Grant SELECT On hr.employee to scott;
                -----------------------------------------"
 _DataBase Objects:
   Definition of DB Objects and Schema:         
                -> https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Database-Objects.html#GUID-31BE00A7-7FF9-41CB-852A-F1416912CA9E
                
                Schema Objects:
                       1.Table   : It is the basic unit of storage.
                       2.View    : It logically represents subsets of data from one or more tables.
                       3.Sequence: It generates numeric values.
                       4.Index   : It improves the performance of some queries.
                       5.Synonym : It gives alternative name to an object.
                Non-Schema Objects:
                Edited Objects:
                             Packages    (PL/SQL)
                             Procedures  (no return)
                             Functions   (return) 
                             Triggers
   "Views":
         Guidlines:
             _________________________________________________________________________________________
             -> It is a schema database object 
             -> It logically represents subsets or combinations of data by creating views from
                one or more tables. 
             -> It is a stored 'SELECT' statement based on a table or another view.
             -> The view is stored as a 'SELECT' statement in the data dictionary.
             -> It contains no data of its own, but it is like a window throught which data from
                tables can be viewed or changed.
             -> The tables on which a view is based are called 'base tables'. 
             -> 'VIEW' information are stored in data dictionary view called 'USER_VIEWS'.
             -> You can drop a view without losing data as a view is based on underlying tables in DB.
             -> To drop an 'VIEW', y must be the owner of the view, or have the 'DROP ANY VIEW'privilege.
             ----------------------------------------------------------------------------------------
             -> It restricts access to the data becuase it displaies selected columns from the table.
             -> It can be used to make simple queries to retrieve the results of complicated queries.
             -> One view can be used to retrieve data from several tables.
             -> Views provide groups of users access to data according to thier particular criteria.
             -> It provides data independence.
             ---------------------------------------------------------------------------------------- 
             -> You can create a view by embedding a subquery in the 'CREATE VIEW' statement.
             -> "OR REPLACE" cluase: 
                           -> it re-create the view if it already exists.
                           -> you can use this cluase to change the definition of
                              an existing view without dropping it. 
             -> "FORCE" cluase:
                           -> It creates the view regardless of whether or not the base tables exist.
             -> "NOFORCE" cluase:
                           -> It creates the view only if the base tables exist(this is the defualt).
             -> "WITH CHECK OPTION" cluase:
                           -> It specifies that only those rows that
                              are accessible to the view can be inserted or updated.
             -> "WITH READ ONLY" cluase:  
                           -> It insures that no DML operations can be performed on this view.
             ----------------------------------------------------------------------------------------
                                  |Rules for performing DML operations on a View|
                                   ---------------------------------------------           
             -> you can usually perform DML operations on 'Simple Views'.
             -> Delete operation : 
                                     You cannot remove a row if the view contains the following :
                                     1.Group Functions.
                                     2.A 'GROUP BY' cluase.
                                     3.The 'DISTINCT' keyword.
                                     4.The pseudocolumn 'ROWNUM' keyword.
             -> Modify operation : 
                                     You cannot modify a row if the view contains the following :
                                     1.Group Functions.
                                     2.A 'GROUP BY' cluase.
                                     3.The 'DISTINCT' keyword.
                                     4.The pseudocolumn 'ROWNUM' keyword.
                                     5.Column defined by expressions. //salary*12
             -> Add operation : 
                                     You cannot remove a row if the view contains the following :
                                     1.Group Functions.
                                     2.A 'GROUP BY' cluase.
                                     3.The 'DISTINCT' keyword.
                                     4.The pseudocolumn 'ROWNUM' keyword.
                                     5.Column defined by expressions. //salary*12
                                     6.NOT NULL columns without defualt value in 
                                       the base tables that are not selected by the view.                                                                      
             _________________________________________________________________________________________
         Types:
              1.Simple  View.         
              2.Complex View.
              3.Materialized View.   
                     /*__________________________________________________________________________
                      |        Feature                  |   Simple View   |   Complex View       |  
                      |_________________________________|_________________|______________________|
                      | Number of tables.               |    one table    |  one or more tables  |
                      |---------------------------------|-----------------|----------------------|
                      | Contains functions.             |      NO         |         YES          |
                      |---------------------------------|-----------------|----------------------|
                      | Contains groups,joins,subquries.|      NO         |         YES          |  
                      |---------------------------------|-----------------|----------------------|
                      | DML operations throught it.     |      YES        |         Rarley       | 
                      |_________________________________|_________________|______________________|*/               
         Syntax:
              Createing View:
                          /*___________________
                          CREATE VIEW view_name
                          AS     
                          SELECT_statement;
                          ----------------=----------------
                          CREATE OR REPLACE VIEW view_name
                          AS     
                          SELECT_statement; */
                         "-----------------------------
                          CREATE FORCE VIEW view_name
                          AS     
                          SELECT_statement;
                          -----------------------------
                          CREATE NOFORCE VIEW view_name
                          AS     
                          SELECT_statement;"
                         /*-------------------------------
                          CREATE OR REPLACE VIEW view_name
                          AS     
                          SELECT_statement
                          WITH CHECK OPTION CONSTRAINT const_name;
                          -----------------------------------------
                          CREATE OR REPLACE VIEW view_name
                          AS     
                          SELECT_statement
                          WITH READ ONLY CONSTRAINT const_name;  
                          -----------------------------------------*/
                         "CREATE VIEW view_name(col1,col2,col3,...)   //alias names for cols in SELECT.
                          AS                                         //number of aliases listed must match
                          SELECT_statement;                            the number of expressions selected
                          -----------------------------------------    the subquery.
                          CREATE VIEW view_name
                          AS     
                          SELECT col1 alias_name, col2 alias_name, col3 alias_name
                          FROM table_name;"
                          _________________________________________________________

              Dropping View:
                         ----------------------
                         "DROP VIEW view_name;"
                         ----------------------
              Describing View:
                         -------------------------------------- 
                         "DESC USER_VIEWS;

                          SELECT VIEW_NAME, TEXT_LENGTH, TEXT
                          FROM   USER_VIEWS
                          WHERE  view_name = 'name';"
                         --------------------------------------

         Example:
   "Sequences":
         Guidlines:
             -> It is a user-created database object that can automatically generate unique numbers.
             -> It is shareable object that can be shared by multiple users to generate integers.
             -> Sequence information are stored in data dictionary view called 'USER_SEQUENCES'.
             -> It can be used to create a primary key value.
             -> It can recycle and use the same number again.
             -> Sequence numbers are stored and generated independent of tables,
                therefore the same sequence can be used for multiple tables.
             -> It can reduce the amount olf application code needed to write 'sequence-generating-function'.
             -> It speeds up the efficiency of accessing sequence values when cached in memory.
             -> if you do not put any 'Sequence Cluase' in Sequence, it will take the defualt cluases.
             -> Do not use the 'Cycle' Option if the sequence is used to generate primary key values.
             -> Y can use the minus(-n) in 'Increment by' cluase, max will be '-1' and min will be '-n'.
             -> 'NEXTVAL' / 'CURRVAL' Pseudocolumns:
                         -> 'NEXTVAL' used to return the next available sequence value, it return 
                             a unique value every time it is referenced,even for different users.
                         -> 'CURRVAL' used to return the current sequence value.
                         -> Know about restriction on these Pseudocolumns.  
             -> Caching sequence values in memory gives faster access to those values.
             -> Gaps in sequence values can occur when :
                            _A 'RollBack' occurs.
                            _The system crashes.
                            _A sequence is used to in another table.
             Modifying A Sequence:
                        -> You can modify the Sequence using 'ALTER' statement.
                        -> You must be the owner of the SEQUENCE or have the 'ALTER' Privilege for it.
                        -> Only future numbers are affected.
                        -> You can modify the 'Increment by n'/'MaxValue n'/'MinValue n',
                                              'Cycle'/'NoCycle'/'Cache n'/'NoCache' only.
                        -> The 'StartWith' Option cannot be changed using ALTER SEQUENCE, the sequence must
                           be dropped and re-created to re-staret the sequence at a different number.
                        -> 'MaxValue' cannot be changed to a value that
                           is less than current value of the sequence.
             -> You can drop the SEQUENCE. 
             -> Y can put 'Sequence.NEXTVAL' as defualt value for primary key when createing a table.                                                     
                                  
         Sequence Cluases:
                     All Sequence Cluases:
                          ___________________________________________________________
                         |  'Increment by n'  |   'MaxValue n'    |   'MinValue n'   |
                         |  'StartWith n'     |   'NoMaxValue'    |   'NoMinValue'   | 
                         |--------------------|-------------------|------------------|
                         |  'Order'           |     'Cycle'       |     'Cache n'    |    
                         |  'NoOrder'         |     'NoCycle'     |     'NoCache'    |
                         |____________________|___________________|__________________|
                     Defualt Sequence Cluases:
                          ___________________________________________________________
                         |  'Increment by 1'  |                   |                  |
                         |  'StartWith 1'     |   'NoMaxValue'    |   'NoMinValue'   | 
                         |--------------------|-------------------|------------------|    
                         |  'NoOrder'         |     'NoCycle'     |     'Cache 20'   |
                         |____________________|___________________|__________________| 
         Syntax:
              Createing Sequence: 
                          --------------------------------------
                          "CREATE SEQUENCE seq_name;"          // it will take the defualt cluases values. 
                          --------------------------------------
                          "CREATE SEQUENCE seq_name SartWith 1;"
                          --------------------------------------
                          "CREATE SEQUENCE seq_name
                                          Increment by 10 
                                          StartWith 21 
                                          MaxValue 9999
                                          NoCycle
                                          NoCache;"
                          --------------------------------------
              Modifying Sequence:
                          "ALTER SEQUENCE seq_name
                                          Increment by 43 
                                          MaxValue 111111
                                          NoCycle
                                          NoCache;"              
              Using Sequence:
                         -------------------------------------------------------
                         "Insert Into table_name(col1            , col2, col3)
                          Values                (seq_name.NEXTVAL, val2, val3);"
                         -------------------------------------------------------
              Dropping Sequence:
                         -------------------------
                         "DROP SEQUENCE seq_name;"
                         ------------------------- 
              Describing Sequence:
                        ---------------------------------------------------------------------- 
                        "DESC USER_SEQUENCES;

                         SELECT sequence_name, min_value, max_value, increment_by, last_number
                         FROM USER_SEQUENCES;"
                        -----------------------------------------------------------------------                         
         Example:
                           -----------------------------------------------------------
                           "CREATE SEQUENCE seq_emp_id;"

                           "SELECT * FROM USER_SEQUENCES
                            WHERE  sequence_name = 'seq_emp_id';"

                           "Insert Into employee(emp_id , fist_name , salary)
                            Values              (seq_emp_id.NEXTVAL , 'Ahmed', 4899);"

                           "SELECT seq_emp_id.CURVAL  FROM DUAL;"
                           "SELECT seq_emp_id.NEXTVAL FROM DUAL;"              //this will cuase gaps.
                           "SELECT seq_emp_id.CURVAL FROM DUAL;"

                           "UPDATE employee
                            SET    emp_id = seq_emp_id.NEXTVAL;"

                           "DROP SEQUENCE seq_emp_id;"
                           -----------------------------------------------------------
                           "CREATE SEQUENCE seq_2
                            Increment by -5;"

                           "Insert Into employee(emp_id , fist_name , salary)
                            Values              (seq_2.NEXTVAL , 'Ahmed', 4899);"

                           "Insert Into employee(emp_id , fist_name , salary)
                            Values              (seq_2.NEXTVAL ,'mohamed', 5555);"
                           ------------------------------------------------------------
                           ---------------------------------------------------------------------
                           Using NEXTVAL and CURRVAL in inserting scripts and data migration.
                           -> When you inserting master details use NEXTVAL with the master and
                              CURRVAL with submaster.
                           ex: 
                              - insert new department called "IT" in department table using  
                                the sequence seq_dept, then
                                insert 3 employees to employee table that work in IT department.

                           "INSERT INTO department(dept_id,dept_name)
                            VALUES                (seq_dept.NEXTVAL , 'IT');

                            INSERT INTO employee(emp_id          , emp_name , dept_id)
                            VALUES              (seq_emp.NEXTVAL , 'ahmed'  , seq_dept.CURRVAL);

                            INSERT INTO employee(emp_id          , emp_name , dept_id)
                            VALUES              (seq_emp.NEXTVAL , 'khalid' , seq_dept.CURRVAL);

                            INSERT INTO employee(emp_id          , emp_name , dept_id)
                            VALUES              (seq_emp.NEXTVAL , 'ali'    , seq_dept.CURRVAL);"
                           ----------------------------------------------------------------------  







                           


   "Index":
         Guidlines: 
             -> It is a schema database object.
             -> Used to speed up the retrival of rows by using a pointer.
             -> It improves the performance of some queries.
             -> It can reduce disc input/output by using a rapid path access method to locate data quickly.
             -> It provides a direct and fast access to rows in a table 
             -> It is dependent on the table that indexes.
             -> It can be created explicitly(by user) or automatically(by DBMS). 
             -> It is used and maintained automatically by the DBMS.
             -> a full table scan occurs if y do not use 'WHERE'cluase.
             -> Index is logically and physically independent of the data in the object with which 
                it is associated, this means that they can be created or dropped at any time, and
                have no effect on the base tble or other indexes.
             -> When you drop a table, the corresponding indexes are also drpped.
             -> Automatically: a 'unique index' is created automatically when 
                               you define a 'Primary Key'or'Unique' constraint in a table definition,
                               and the name of the index will be the constraint name.
             -> Manually : you can create unique(DBMS or USER) or nonunique(USER/foreign Key) index
                               on columns to speed access to the rows.     
             -> 'UNIQUE INDEX': the value of the indexed columns must be unique.
             -> 'BITMAP INDEX': for distict value(male,female).
             -> Function-Based Indexes: 
                              it is based on expression.
                              -> the index expression is built from table columns, constrains,
                                 SQL functions, and user defined functions.                                
             -> When i should create index:
                    1.A column contains a wide range of values.
                    2.A column contains a large numbers of NULL values.
                    3.One or more columns are frequently used together in'WHERE'cluase or'JOIN'condition.
                    4.The table is large and most queries are expected to retrieved < 2% to 4% of the rows.
             -> When i should not create index:
                    1.The columns are not often used as a condition in the query.
                    2.The table is updated frequently.
                    3.The indexed columns are referenced as part of an expression.
                    4.The table is small or most queries are expected to retrieved > 2% to 4% of the rows.
             -> INDEX info are stored in data dictionary view called :
                                       'USER_INDEXES'/'USER_IND_COLUMNS'/'USER_IND_EXPRESSIONS'.
             -> You can not modify indexes, to change it y must drop it and then re-create it again.
             -> You can drop the INDEX.  
             -> To drop an 'index', y must be the owner of the index, or have the 'DROP ANY INDEX'privilege. 
             -> 'ONLINE': 
                    -> You can drop an idex using teh 'ONLINE' keyword. 
                    -> It indicates the DML operations on the table are allowed while dropping the index. 
             -> When y drop a table, indexes and constraints are automatically dropped, but views remain.   
             -> 'USING INDEX' : You can rename the index created automatically by the system. 
             -> "Explain Plan" : it shows you if the index is used or not.            
         Syntax: 
              Creating Index:
                          ----------------------------   
                         "CREATE INDEX index_name
                          ON     table_name(col_name);         //one column.
                          ----------------------------
                          CREATE INDEX index_name              //many columns.
                          ON     table_name(col_name1,col_name2,col_name3,...,...);
                          ---------------------------------------------------------
                          CREATE UNIQUE INDEX inx_name
                          ON     table_name(col_name);
                          ----------------------------
                          CREATE BITMAP INDEX inx_name
                          ON     table_name(col_name);
                          ----------------------------------
                          CREATE INDEX inx_name
                          ON     table_name(Fun(col_name));"     //function-based-index.
                          ----------------------------------
              Dropping INDEX:
                         ------------------------
                         "DROP INDEX index_name;"
                         -------------------------------
                         "DROP INDEX index_name ONLINE;"
                         ------------------------------- 
              Describing INDEX:
                        ---------------------------------------------------------------------- 
                        "DESC USER_INDEXES;

                         SELECT *
                         FROM   USER_INDEXES               //information about index.
                         WHERE  table_name = 'employee';
                         
                         SELECT *
                         FROM   USER_IND_COLUMNS          //which column is indexed
                         WHERE  table_name = 'employee';

                         SELECT *
                         FROM   USER_IND_EXPRESSIONS      //for function-based-index.
                         WHERE  table_name = 'employee';"

                        "SELECT *
                         FROM   USER_INDEXES 
                         JOIN   USER_IND_COLUMNS
                         ON     (USER_INDEXES.index_name = USER_IND_COLUMNS.index_name)"

                        -----------------------------------------------------------------------
              Rename automatically created INDEX:
                        -------------------------------------------------------------
                        "Create TABLE employee
                         (
                             
                             emp_id NUMBER(8) CONSTRAINT const_name PRIMARY KEY USING INDEX
                                              (
                                                   CREATE INDEX pk_idx_emp_id
                                                   ON     employee(emp_id);
                                              )
                             first_name VARCHAR2(22) NOT NULL
                             dept_id NUMBER(8) 
                         )";
                        ------------------------------------------------------------                                                       
         Example:
              Creating Index:
                          ----------------------------   
                         "CREATE INDEX emp_ind_pk
                          ON     employee(emp_id);
                          ----------------------------
                          CREATE INDEX emp_ind_pk
                          ON     employee(emp_id,first_name);
                          -----------------------------------
                          CREATE UNIQUE INDEX emp_ind_pk
                          ON     employee(emp_id);
                          -----------------------------------
                          CREATE BITMAP INDEX emp_ind_pk
                          ON     employee(gender);
                          ----------------------------------
                          CREATE INDEX emp_ind_pk
                          ON     employee(UPPER(first_name));
                          
                          SELECT emp_id, first_name
                          FROM   employee
                          WHERE  UPPER(first_name) = 'AHMED';"  
                          ----------------------------------
              Dropping INDEX:
                         ------------------------
                         "DROP INDEX emp_ind_pk;"
                         -------------------------------
                         "DROP INDEX emp_ind_pk ONLINE;"
                         ------------------------------- 
              Describing INDEX:
                        ---------------------------------------------------------------------- 
                        "DESC USER_INDEXES;"
                        -----------------------------------------------------------------------  
   "Synonym":  
         Guidlines:
             -> It is a database object created to give an alternative name to an object(table,view,..).
             -> It requires no storage other than its definition in the data dictionary.
             -> It is useful for hiding the identity and location of an underlying schema object.
             -> 'PUBLIC' cluase refers to that Synonym is accessible to all users.
             -> To create a 'PUBLIC' synonym, y must have the 'CREATE PUBLIC SYNONYM' privilege from DBA.
             -> Only DBA can drop 'PUBLIC' synonym.
             -> Y can give a Synonym to a Package itself, but y cannot
                give a Synonym to an object contained in a 'Package'.
         Syntax:
              Createing Synonym: 
                           ------------------------------
                          "CREATE SYNONYM syn_name
                           FOR    object_name;
                           ------------------------------
                           CREATE PUBLIC SYNONYM syn_name
                           FOR    user_name.object_name;
                           ------------------------------ 
                           CREATE PUBLIC SYNONYM syn_name
                           FOR    object_name;"
                           ------------------------------
              Dropping Synonym:
                           ------------------------------
                          "DROP SYNONYM syn_name;"
                           ------------------------------
                          "DROP PUBLIC SYNONYM syn_name;"
                           ------------------------------
              Describing Synonym:
                           ----------------------------
                          "SELECT * FROM USER_SYNONYM;"
                           ----------------------------             

         Example:               
                           "CREATE SYNONYM emp
                            FOR    employee; 

                            DROP SYNONYM emp;"    
   "Temporary Tables":
         Guidlines:
             -> It is a temporary table is a special type of table that
                allows you to store a temporary result set, 
                which you can reuse several times in a single session.
             -> It is visible only to the current session,
                and is dropped automatically when the session is closed.
             ->
         Syntax:
              Createing Temporary Table:
                          -----------------------------------------
                         "CREATE GLOBAL TEMPORARY TABLE table_name
                          (
                                col1_name DATATYPE,
                                col2_name DATATYPE
                          )
                          ON COMMIT DELETE ROWS;" 
                          -----------------------------------------
                         "CREATE GLOBAL TEMPORARY TABLE table_name
                          (
                                col1_name DATATYPE,
                                col2_name DATATYPE
                          )
                          ON COMMIT PRESERVE ROWS;"   
                          -----------------------------------------
              Dropping Temporary Table:
                          ---------------------------------- 
                          "DROP TEMPORARY TABLE table_name;"
                          ----------------------------------             
         Example:
   "External Tables": 
         Guidlines:
             -> https://www.youtube.com/watch?v=gTlyhtyjRb0&list=PLTChhmU8tbQzrdP79gFX6h4TXu-gOUDvp&index=91&pp=iAQB
         Syntax:
              Createing Synonym:
                          ----------------------------------
                         ""
         Example:                       
 _Data Dictionary:
       Definition:  see KHALID ALKHUDARI
       Types: 
            1.Data Dictionary Tables:
                       -> It is created by user.
                       -> It is tables containing business data.
                       -> Like : 'employee','department','locations','jop'.
            2.Data Dictionary Views:
                       -> It is created by the ORACLE/MySql servers.
                       -> It consists of : 
                                      _Base Tables.
                                      _User-Accessible-Views. 
                       -> It is READ ONLY Views.
                       -> All 'Dictionary Views' are stored in 'Dictionary'.
                       -> DDVs naming convention:
                           _______________________________________________________________________
                          |  View Prefix                          Purpose                         |
                          |    'USER'  ->  It is a view containing informations about objects,    |
                          |                that you own or you created like 'USER_OBJECTS'.       |
                          |    'ALL'   ->  It is a view containing informations about all objects,|
                          |                to which you have access 'ALL_OBJECTS'.                |
                          |    'DBA'   ->  It is a view containing informations about all objects,|
                          |                that are own by all users 'DBA_OBJECTS'.               |
                          |    'V$'    ->  It is a view containing informations about performance.|
                          |_______________________________________________________________________|    

                       -> Like : 'DICTIONARY','USER_OBJECTS','USER_TABLES','USER_TAB_COLUMNS'.
                       -> Y can query the Dictionary Views,
                          that are based on the Dictionary Tables to 
                          find information such as :
                                        1.Definition of all schema objects in the database.
                                        2.Defualt values for columns.
                                        3.Integrity constraint information.
                                        4.Names of Users.
                                        5.Privileges and Roles that each user has been granted.
                                        6.Other general database information.
                       -> Y always access Dictionary Views and no need to know how it created by SYS.
                       -> Y can access it by Select statement:
                                       "SELECT TABLE_NAME 
                                        FROM   USER_TABLES; "
                       > DICTIONARY table is a table containing
                         the names and descriptions of the dictionary tables and views,
                         the names are stored in Uppercase letters.
                         Syntax:
                                       "DESC DICTIONARY;
                                        ------------------------------------
                                        SELECT * FROM DICTIONARY;
                                        ------------------------------------    
                                        SELECT * FROM DICTIONARY
                                        WHERE    TABLE_NAME = 'USER_OBJECTS';
                                        ------------------------------------"      
                    Some data dictionary views:
                            -> Sequence information are stored in data dictionary view called 'USER_SEQUENCES'.                                               
 


____________________________________________Advanced SQL Concepts___________________________________________

  1_DBA / User / Schema / Object / Privilege:
           -> https://www.youtube.com/watch?v=pvj2vDuQD2A&list=PLTChhmU8tbQzrdP79gFX6h4TXu-gOUDvp&index=99&pp=iAQB
           1.DBA :
                 -> https://www.geeksforgeeks.org/dba-full-form/
                 -> DBA is the information technician who directs and performs all activities
                    related to Database Like :
                                   _Maintaining  DB.          _Authorizing access to DB.
                                   _Controlling  DB.          _Capacity of DB.
                                   _Coordinating DB.          _Planning.
                                   _Operating DB.             _Installation.
                                   _Managing  DB.             _Monitoring uses.
                                   _Securing  DB.             _Taking care of DB.
                                   _Gathering software and hardware resources.
                 -> DBA is a high-level user with the ability to create users and grant users access  
                    to the database and its objects.
                 -> Users can be given the privilege to grant additional privileges to
                    other users or to roles.  
                 -> DBA has the following abilities:
                           1.Creating Users:
                                        "CREATE USER   user_name
                                         IDENTIFIED BY user_password;"      
                           2.Changing user password:
                                        "ALTER  USER   user_name
                                         IDENTIFIED BY new_password;"
                           3.Creating table space:
                                        "CREATE TABLESPACE ts_name
                                         DATAFILE 'datafile path' 
                                         SIZE 1m;"              
                           4.Granting a space to a user: 
                                        "GRANT UNLIMITED TABLESPACE 
                                         TO    user_name;"             
                           5.Granting System Privileges:
                                        "GRANT sys_priv1, sys_priv2, ...,...
                                         TO    user_name/role_name/PUBLIC;"  
                           6.Granting Object Privileges:
                                        "GRANT obj_priv
                                         ON    user_name.obj_name
                                         TO    user_name/role_name/PUBLIC
                                         WITH GRANT OPTION;"           //with grant option is optional.
                                         --------------------------------------------------------------
                                        "GRANT obj_priv(column1, column2, ...)
                                         ON    user_name.obj_name
                                         TO    user1, user2, ...;"                             
                           7.Creating, Granting, and Revoking a role to the user:
                                         a.Creating a role:
                                                   "CREATE ROLE role_name;"
                                         b.Grant privileges to a role:
                                                   "GRANT priv1, priv2, ...
                                                    TO    role_name;"
                                         c.Grant a role to a user:
                                                   "GRANT role_name
                                                    TO    user_name;"
                                         d.Revoke a role from user:
                                                   "REVOKE role_name
                                                    FROM   user_name;"             
                           8.Removing Object Privileges:
                                         "REVOKE priv1, priv2, .../All
                                          ON     object_name
                                          FROM   user_name/role_name/PUBLIC
                                          CASCADE CONSTRAINTS;"         //it is optional.  
                           9.Dropping users:
                                         "DROP USER user_name;"          //if the user has no objects.
                                         "DROP USER user_name CASCADE;"  //if the user has objects.                  
           2.User:
                 -> https://www.geeksforgeeks.org/different-types-of-database-users/
                 -> Database users are a person who interacts with data, 
                    and depending on their role and tasks they have different 
                    levels of access and rights within a database. 
                 -> Database users understand the importance of data security,
                    privacy, and integrity and know the query data from databases using SQL or other tools.
                 -> Users can be given the privilege to grant additional privileges to
                    other users or to roles.
                 -> Createing user:
                              "CREATE USER   user_name
                               IDENTIFIED BY user_password;"
                 -> Changing user password:
                              "ALTER  USER   user_name
                               IDENTIFIED BY new_password;"                     
           3.Schema:
                 -> https://www.geeksforgeeks.org/database-schemas/
                 -> It is a collection of objects such as tables, views, indexes, ..etc.
                 -> It is owned by a database user and has the same name as that user.
           4.Object:
                 -> https://www.geeksforgeeks.org/database-objects-in-dbms/
                 ->
           5.Privilege:
                 -> https://www.geeksforgeeks.org/privilege-and-roles-in-dbms/
                 -> It is the right to execute particular SQL statement.
                 -> Search for the data dictionary of privileges.
                 -> Types:
                       1.System Privileges:
                                -> It is the right to perform a particular action on
                                   any schema objects of a particular type.
                                -> Users requires system privileges to gain access to the database.
                                -> Current system privileges are found in 'SESSION_PRIVS' dictionary view. 
                                -> Some system privileges:
                                          "CREATE USER"      "CREATE ANY TABLE"
                                          "DROP USER"        "SELECT ANY TABLE"  
                                          "DROP ANY TABLE"   "BACKUP ANY TABLE"
                                          "CREATE SESSION"   "CREATE TABLE"
                                          "CREATE VIEW"      "CREATE PROCEDURE"
                       2.Object Privileges:
                                -> It provides the user ability to manipulate the content
                                   of the database objects. 
                                -> Users requires object privileges to manipulate the content of
                                   the objects in the database.
                                -> A user automatically has all object privilegesfor schema objects
                                   contained in the user schema.
                                -> A user can grant any object privilege on any schema object that 
                                   the user owns to any other user, if the grant 
                                   includes WITH GRANT OPTION , the grantee can further grant the
                                   object privilege to other users, if the grant does not include it,
                                   the grantee can use the privilege but cannot grant it to other users.      
                                -> Current object privileges are found in 'ALL_TAP_PRIVS_MADEz ' dictionary view. 
                                -> Some object privileges: 
                                          "ALTER"            "DELETE"
                                          "INDEX"            "INSERT"
                                          "REFERENCES"       "SELECT"
                                          "UPDATE"   
                                       
           6.Roles:
                 -> https://www.geeksforgeeks.org/privilege-and-roles-in-dbms/
                 -> https://www.geeksforgeeks.org/sql-creating-roles/
                 -> It is a database object that groups together one or 
                    more privileges and can be assigned to users
                 -> It is a collection of privileges that can be granted to either
                    a database user or another role in runtime. 
                 -> It is a named group of related privileges that can be granted to the user.
                 -> It is typically created for a database applications. 
                 Syntax:        
                          1.Creating a role:
                                    "CREATE ROLE role_name;"
                          2.Grant privileges to a role:
                                    "GRANT priv1, priv2, ...
                                     TO    role_name;"
                          3.Grant a role to a user:
                                    "GRANT role_name
                                     TO    user_name;"                      
  12_Database Security:
           -> https://www.oracle.com/eg/security/database-security/what-is-data-security/
           -> https://azure.microsoft.com/en-us/resources/cloud-computing-dictionary/what-is-database-security#:~:text=Database%20security%20is%20the%20processes,and%20integrity%20of%20the%20database.
           -> It is the processes, tools, and controls that secure and protect
              databases against accidental and intentional threats,
              the objective of database security is to secure sensitive data and
              maintain the confidentiality, availability, and integrity of the database.      
  11_Database Integrity:
           -> https://www.quora.com/What-is-database-integrity
           -> https://www.javatpoint.com/what-is-data-integrity
           -> It refers to the accuracy, consistency, and reliability of the data stored in a database.
  2_Explain Plan.
  3_SQL Loader:
       -> Data from outside the DB to inside DB.
        https://www.youtube.com/watch?v=ZknERI4lsmU&list=PLTChhmU8tbQzrdP79gFX6h4TXu-gOUDvp&index=90&pp=iAQB       
  4_DataBase directories:
        https://www.youtube.com/watch?v=gTlyhtyjRb0&list=PLTChhmU8tbQzrdP79gFX6h4TXu-gOUDvp&index=91&pp=iAQB
  5_External Tables:
        -> Data from inside the DB to outside DB.
        https://www.youtube.com/watch?v=gTlyhtyjRb0&list=PLTChhmU8tbQzrdP79gFX6h4TXu-gOUDvp&index=91&pp=iAQB       
        https://www.youtube.com/watch?v=VIEnM86rDEQ&list=PLTChhmU8tbQzrdP79gFX6h4TXu-gOUDvp&index=92&pp=iAQB
  6_Data Pump.
  7_DataBase Backup.
  8_DataBase Migration.
  9_Dynamic SQL.
  10_Database Links.
  
  
  13_Query Optimization.
  14_Query Analysis.
  15_Database Hosting.
  17_File Organization:
           -> https://www.geeksforgeeks.org/file-organization-in-dbms-set-1/?ref=lbp
  18_Normalisation:
           -> https://www.geeksforgeeks.org/database-normalization-introduction/
  19_Transactions:
           -> https://www.geeksforgeeks.org/concurrency-control-introduction/
  20_Concurrency Control:
           -> https://www.geeksforgeeks.org/concurrency-control-introduction/  
  21_Functional Dependencies: 
           -> https://www.geeksforgeeks.org/dbms/?ref=shm#:~:text=Functional%20Dependencies%20%3A               
  ------------------ 

__________________________________________More Advanced SQL Concepts________________________________________


                                                        
  2_Recursive Query.                                        
  4_Window Function.                                              
  5_Common Table Expression "CTEs".







               
               
               
               
               





                                      