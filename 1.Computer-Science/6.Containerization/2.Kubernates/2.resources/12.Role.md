___________________________________________________________________________________________________________________________

---

## üîê What is a `Role` in Kubernetes?

A **`Role`** is a Kubernetes **RBAC (Role-Based Access Control)** object that defines a **set of permissions (rules)** **within a specific namespace**.

It‚Äôs used to:

* Control **what users, groups, or ServiceAccounts can do** (get, list, create, delete, etc.)
* Limit actions **only within a namespace**
* Apply the **principle of least privilege**

---

## üß† Role vs ClusterRole

| Feature                            | `Role`         | `ClusterRole`                         |
| ---------------------------------- | -------------- | ------------------------------------- |
| Scope                              | **Namespaced** | **Cluster-wide** (non-namespaced)     |
| Used with                          | `RoleBinding`  | `ClusterRoleBinding` (or RoleBinding) |
| Can access cluster-wide resources? | ‚ùå No           | ‚úÖ Yes                                 |

---

## üßæ Role YAML Structure (Simple Example)

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: pod-reader
  namespace: dev
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list", "watch"]
```

‚úÖ This allows **read-only access to pods** **within the `dev` namespace**.

---

## üîç Key Fields in `Role`

| Field                      | Description                                                                 |
| -------------------------- | --------------------------------------------------------------------------- |
| `apiGroups`                | The API group of the resource (e.g., `apps`, `batch`, or `""` for core API) |
| `resources`                | Resource types: `pods`, `services`, `configmaps`, etc.                      |
| `verbs`                    | Allowed actions: `get`, `list`, `create`, `delete`, `patch`, etc.           |
| `resourceNames` (optional) | Specific named resources you want to restrict access to                     |

---

## üîó RoleBinding: Assigning a Role

To give a Role to a subject (user, group, service account), use a `RoleBinding`:

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: bind-pod-reader
  namespace: dev
subjects:
- kind: ServiceAccount
  name: frontend-sa
  namespace: dev
roleRef:
  kind: Role
  name: pod-reader
  apiGroup: rbac.authorization.k8s.io
```

This allows the `frontend-sa` **ServiceAccount** to **read pods** in the `dev` namespace.

---

## ‚úÖ Example Use Case: Developer Access

Allow developers to manage ConfigMaps but not secrets:

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: configmap-editor
  namespace: dev
rules:
- apiGroups: [""]
  resources: ["configmaps"]
  verbs: ["get", "list", "create", "update", "delete"]
```

Bind it with a RoleBinding to the developer's service account.

---

## üß™ Advanced Example: Resource Name Restriction

Allow access to a **specific pod** only:

```yaml
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get"]
  resourceNames: ["backend-pod"]
```

---

## üõ°Ô∏è Role for Custom Resources (CRDs)

To access a custom resource:

```yaml
apiGroups: ["mycompany.io"]
resources: ["widgets"]
verbs: ["get", "list"]
```

---

## üë®‚Äçüë©‚Äçüëß‚Äçüë¶ Supported Subject Kinds in RoleBinding

* `User`: an authenticated user
* `Group`: a group of users (via external auth)
* `ServiceAccount`: most common for in-cluster pods

---

## üìò CLI Examples

### Create Role via CLI

```bash
kubectl create role config-reader \
  --verb=get,list \
  --resource=configmaps \
  --namespace=dev
```

### Create RoleBinding via CLI

```bash
kubectl create rolebinding read-configmaps \
  --role=config-reader \
  --serviceaccount=dev:frontend-sa \
  --namespace=dev
```

---

## üîê Best Practices

| Practice                             | Why It‚Äôs Important                               |
| ------------------------------------ | ------------------------------------------------ |
| Use `Role` for namespaced resources  | Follows least privilege principle                |
| One Role per app/serviceaccount      | Easier auditing and maintenance                  |
| Avoid giving wide `*` access         | Reduces risk of privilege escalation             |
| Combine with `ServiceAccount` + PDB  | For secure and HA workloads                      |
| Use `kubectl auth can-i` for testing | Validate access rules without deploying anything |

```bash
kubectl auth can-i get pods --as=system:serviceaccount:dev:frontend-sa -n dev
```

---

## üìú Summary Table

| Resource      | Scope        | Bound With                            | Use Case                              |
| ------------- | ------------ | ------------------------------------- | ------------------------------------- |
| `Role`        | Namespaced   | `RoleBinding`                         | Pod/ConfigMap/Secret access in one ns |
| `ClusterRole` | Cluster-wide | `ClusterRoleBinding` or `RoleBinding` | Node-wide or multi-namespace access   |

---
