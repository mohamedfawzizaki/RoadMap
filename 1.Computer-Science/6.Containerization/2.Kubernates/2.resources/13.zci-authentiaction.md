Hereâ€™s a âœ… **complete script** to automatically generate a **`kubeconfig` file** for a Kubernetes **ServiceAccount**, perfect for CI/CD or external tooling.

---

### ğŸ§¾ What this script does:

1. Creates a ServiceAccount (if it doesn't exist)
2. Creates a ClusterRoleBinding to give it access
3. Generates a temporary token using `kubectl create token`
4. Extracts the cluster endpoint and CA
5. Generates a ready-to-use `kubeconfig` file

---

### âœ… **Bash Script** (Linux/macOS/WSL compatible)

```bash
#!/bin/bash

set -e

# ğŸ”§ CONFIG
SA_NAME="ci-user"
NAMESPACE="kube-system"
CLUSTER_NAME=$(kubectl config view --minify -o jsonpath='{.clusters[0].name}')
KUBECONFIG_FILE="kubeconfig-${SA_NAME}.yaml"

# ğŸ›  Create ServiceAccount
kubectl get serviceaccount "${SA_NAME}" -n "${NAMESPACE}" >/dev/null 2>&1 || \
kubectl create serviceaccount "${SA_NAME}" -n "${NAMESPACE}"

# ğŸ” Create ClusterRoleBinding (cluster-admin for full access)
kubectl get clusterrolebinding "${SA_NAME}-binding" >/dev/null 2>&1 || \
kubectl create clusterrolebinding "${SA_NAME}-binding" \
  --clusterrole=cluster-admin \
  --serviceaccount="${NAMESPACE}:${SA_NAME}"

# ğŸ”‘ Create token (Kubernetes v1.24+)
TOKEN=$(kubectl create token "${SA_NAME}" -n "${NAMESPACE}")

# ğŸŒ Get cluster endpoint and CA
CLUSTER_ENDPOINT=$(kubectl config view --minify -o jsonpath='{.clusters[0].cluster.server}')
CA_DATA=$(kubectl config view --raw --minify -o jsonpath='{.clusters[0].cluster.certificate-authority-data}')

# ğŸ§¾ Generate kubeconfig file
cat <<EOF > "${KUBECONFIG_FILE}"
apiVersion: v1
kind: Config
clusters:
- name: ${CLUSTER_NAME}
  cluster:
    server: ${CLUSTER_ENDPOINT}
    certificate-authority-data: ${CA_DATA}
users:
- name: ${SA_NAME}
  user:
    token: ${TOKEN}
contexts:
- name: ${SA_NAME}-context
  context:
    cluster: ${CLUSTER_NAME}
    user: ${SA_NAME}
    namespace: ${NAMESPACE}
current-context: ${SA_NAME}-context
EOF

echo "âœ… kubeconfig saved to: ${KUBECONFIG_FILE}"
```

---

### ğŸ§ª Example Output

```bash
$ bash generate-kubeconfig.sh
serviceaccount/ci-user created
clusterrolebinding.rbac.authorization.k8s.io/ci-user-binding created
âœ… kubeconfig saved to: kubeconfig-ci-user.yaml
```

---

### ğŸ§° Usage

You can now use the file:

```bash
kubectl --kubeconfig=kubeconfig-ci-user.yaml get pods -n kube-system
```

In CI/CD (e.g. GitHub Actions):

```yaml
- name: Set up kubeconfig
  run: echo "$KUBECONFIG_DATA" | base64 -d > ~/.kube/config
  env:
    KUBECONFIG_DATA: ${{ secrets.KUBECONFIG_DATA }}
```

> Use `base64 -w 0 kubeconfig-ci-user.yaml` to upload to secrets.

---

### âœ… Optional: Restrict Permissions

Instead of binding `cluster-admin`, define a custom `ClusterRole` or `Role` to limit access (e.g., read-only or namespace-scoped).

---

Would you like a version of this:

* ğŸ”’ Using **minimal RBAC permissions**?
* ğŸ“¦ Bundled as a **Helm chart** or **Terraform module**?
* ğŸª„ As a reusable **GitHub Action step** or script for `Jenkins`/`GitLab`?
