___________________________________________________________________________________________________________________________

---

## 🚧 What is `ResourceQuota`?

A `ResourceQuota` **limits the total amount of compute resources or object counts** that can be consumed in a **namespace**.

Think of it as **budget control** per namespace:

* 🧠 CPU & memory usage limits
* 💾 Storage limits
* 📦 Number of objects (pods, services, PVCs, etc.)

It ensures **fair resource sharing** and prevents any one namespace from starving the others.

---

## 🧱 ResourceQuota Structure (YAML)

```yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: dev-quota
  namespace: dev
spec:
  hard:
    pods: "10"
    requests.cpu: "2"
    limits.cpu: "4"
    requests.memory: "4Gi"
    limits.memory: "8Gi"
    persistentvolumeclaims: "5"
```

### 🔑 Key Fields

| Field                | Description                        |
| -------------------- | ---------------------------------- |
| `metadata.name`      | Name of the ResourceQuota object   |
| `metadata.namespace` | Namespace it applies to            |
| `spec.hard`          | The limits (quotas) to be enforced |

---

## 🔢 Types of Resources You Can Limit

### ✔️ Compute Resources

| Resource          | Description                         |
| ----------------- | ----------------------------------- |
| `requests.cpu`    | Total CPU requested across all pods |
| `limits.cpu`      | Total CPU limit allowed             |
| `requests.memory` | Total memory requested              |
| `limits.memory`   | Total memory limit allowed          |

### ✔️ Object Counts

| Resource                 | Description                 |
| ------------------------ | --------------------------- |
| `pods`                   | Max number of pods          |
| `services`               | Max services                |
| `replicationcontrollers` | Max replication controllers |
| `secrets`                | Max secrets                 |
| `configmaps`             | Max configmaps              |
| `persistentvolumeclaims` | Max PVCs                    |

### ✔️ Storage

| Resource                           | Description                         |
| ---------------------------------- | ----------------------------------- |
| `requests.storage`                 | Total requested storage across PVCs |
| `requests.<storage-class>.storage` | Per-storage-class quota             |

---

## 🎯 Example Use Case

Suppose a dev namespace should only use:

* Max 10 pods
* Max 2 CPUs requested
* Max 4Gi memory requested

```yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: dev-quota
  namespace: dev
spec:
  hard:
    pods: "10"
    requests.cpu: "2"
    requests.memory: "4Gi"
```

---

## ✅ Applying the ResourceQuota

```bash
kubectl apply -f dev-quota.yaml
```

---

## 📊 Check Quota Usage

```bash
kubectl describe quota dev-quota -n dev
```

Sample output:

```
Resource                Used  Hard
--------                ----  ----
pods                   3     10
requests.cpu           1     2
requests.memory        2Gi   4Gi
```

---

## 🔄 How it Works with Pod Scheduling

When you create a pod:

* Kubernetes checks the **cumulative resource usage in the namespace**
* If adding the pod would exceed any quota, the pod is **rejected** and not scheduled

---

## ⚙️ Interaction with LimitRange

* **`LimitRange`** sets default/request/limit **per pod/container**
* **`ResourceQuota`** sets total usage **per namespace**

Example:

```yaml
# default memory limit per container
kind: LimitRange
spec:
  limits:
  - default:
      memory: 512Mi
    type: Container
```

Combined with:

```yaml
# total quota per namespace
kind: ResourceQuota
spec:
  hard:
    limits.memory: 2Gi
```

→ You can run up to 4 containers with 512Mi memory in the namespace.

---

## 🛑 Enforcement: What Happens If You Go Over

* **Pod creation fails** with message like:

  ```
  failed quota: dev-quota: must specify memory, CPU, ...
  ```
* If you're under quota but haven't **specified resource requests/limits**, pods may fail to schedule (because Kubernetes can’t evaluate the quota usage).

---

## 🧪 Pro Tip: Force Users to Specify Resources

You can combine quotas with policies to **require users to declare** `resources.requests/limits`.

```yaml
spec:
  scopes:
    - NotTerminating
```

Or apply **LimitRange** to inject defaults.

---

## 🧰 Bonus: Multiple Quotas per Namespace?

Nope — **only one ResourceQuota** is allowed per namespace. However, it can include **many hard limits**.

---

## ✅ Best Practices

| Practice                           | Why It Helps                               |
| ---------------------------------- | ------------------------------------------ |
| Set default `LimitRange`           | Avoid uncontrolled pods that bypass quotas |
| Use quotas for every tenant/env    | Ensure fair resource usage                 |
| Monitor quota usage with `kubectl` | Proactive capacity planning                |
| Combine with `RoleBinding` + `NS`  | Fine-grained access + resource control     |
| Document quota policies            | So developers know how to avoid errors     |

---
