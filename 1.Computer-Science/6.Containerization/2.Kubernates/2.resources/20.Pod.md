___________________________________________________________________________________________________________________________

---

# What is a Pod?

* A **Pod** is the **smallest deployable unit** in Kubernetes.
* It represents **one or more containers** that share:

  * Network namespace (IP address, port space)
  * Storage volumes
  * Lifecycle and scheduling constraints

Think of a Pod as a **logical host** for tightly coupled containers that need to run together.

---

# Pod Anatomy

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: example-pod
  labels:
    app: myapp
spec:
  containers:
  - name: app-container
    image: nginx:latest
    ports:
    - containerPort: 80
```

### Key parts:

* `metadata`: Identifiers and labels for the pod
* `spec`: Defines the container(s) and related resources
* `containers`: List of container specs inside the pod

---

# Core Concepts

### 1. Containers in a Pod

* Pods can run **one or multiple containers**.
* Containers in the same pod share:

  * **Network IP and port space** (localhost communication)
  * **Storage volumes**
* Sidecar containers (e.g., logging, proxy) often live in the same pod.

### 2. Networking

* Each pod gets a **unique IP address** within the cluster.
* Containers inside the pod communicate over `localhost`.
* Ports exposed by containers map to the podâ€™s IP.

### 3. Storage Volumes

* Pods can mount shared volumes.
* Volumes live as long as the pod does.

### 4. Lifecycle

* Pods have phases like `Pending`, `Running`, `Succeeded`, `Failed`, `Unknown`.
* Containers have lifecycle hooks (`postStart`, `preStop`).

---

# Pod Spec Details

### Containers Field

* `image`: Container image to run.
* `name`: Container identifier within pod.
* `ports`: Expose container ports.
* `env`: Environment variables.
* `volumeMounts`: Mount volumes inside container.
* `resources`: CPU/memory requests and limits.
* `livenessProbe` and `readinessProbe`: Health checks.

### Volumes Field

* Defines volumes attached to pod.
* Examples: `emptyDir`, `hostPath`, `configMap`, `secret`, `persistentVolumeClaim`.

---

# Pod Networking

* Pods have their own IP, accessible within the cluster.
* All containers share the same network namespace.
* Communication between pods usually via Services or directly using IP.

---

# Pod Scheduling & Node Assignment

* Pods are scheduled on nodes by the **Kube Scheduler**.
* Scheduling considers:

  * Resource requests/limits
  * Node selectors and affinity/anti-affinity rules
  * Taints and tolerations

---

# Pod Lifecycle Phases

| Phase     | Description                            |
| --------- | -------------------------------------- |
| Pending   | Pod accepted, not yet running          |
| Running   | Pod has at least one running container |
| Succeeded | All containers completed successfully  |
| Failed    | Containers terminated with failure     |
| Unknown   | Status unknown (e.g., node failure)    |

---

# Probes (Health Checks)

* **Liveness Probe**: Restarts container if unhealthy.
* **Readiness Probe**: Controls whether pod receives traffic.
* **Startup Probe**: Used to check container startup time.

---

# Init Containers

* Special containers that run **before app containers** start.
* Used for setup tasks like migrations or config downloads.
* Must complete successfully for pod to start.

---

# Pod Security & Policies

* Can restrict pod capabilities, volumes, and network access.
* Use **PodSecurityPolicy** or **Pod Security Admission** (new in Kubernetes 1.25+).
* Supports **SecurityContext** to set user/group IDs, capabilities, SELinux options.

---

# Pod Templates

* Pods are usually created by **controllers** (Deployments, StatefulSets, DaemonSets) using pod templates.
* Templates define desired state, ensuring pods are replicated and updated.

---

# Example: Full Pod Spec with many features

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: advanced-pod
  labels:
    app: myapp
spec:
  initContainers:
  - name: init-db
    image: busybox
    command: ['sh', '-c', 'echo Initializing DB... && sleep 5']
  containers:
  - name: main-app
    image: nginx:latest
    ports:
    - containerPort: 80
    env:
    - name: ENVIRONMENT
      value: production
    volumeMounts:
    - mountPath: /etc/config
      name: config-volume
    resources:
      requests:
        memory: "128Mi"
        cpu: "250m"
      limits:
        memory: "256Mi"
        cpu: "500m"
    readinessProbe:
      httpGet:
        path: /
        port: 80
      initialDelaySeconds: 5
      periodSeconds: 10
    livenessProbe:
      httpGet:
        path: /
        port: 80
      initialDelaySeconds: 15
      periodSeconds: 20
  volumes:
  - name: config-volume
    configMap:
      name: my-configmap
```

---

# Useful Commands for Pods

* `kubectl get pods`
* `kubectl describe pod <pod-name>`
* `kubectl logs <pod-name> [-c container-name]`
* `kubectl exec -it <pod-name> -- /bin/sh`

---

# Summary

| Aspect                                           | Description                                               |
| ------------------------------------------------ | --------------------------------------------------------- |
| Smallest deployable unit in Kubernetes           | Runs one or more containers that share network & storage  |
| Containers share the same IP and storage volumes | Facilitate tight coupling of processes                    |
| Supports init containers for setup tasks         | Enhances pod startup control                              |
| Supports probes for health checking              | Ensures pod reliability and readiness                     |
| Managed mostly by controllers                    | Pods alone are ephemeral, controllers ensure availability |

---
