___________________________________________________________________________________________________________________________

---

## ğŸ” What is a ServiceAccount in Kubernetes?

A **`ServiceAccount`** is a **Kubernetes identity** used by **pods**, **controllers**, or **applications inside pods** to:

* **Authenticate to the Kubernetes API**
* Access secrets, configmaps, other API objects
* Perform actions (like read/write resources) based on **RBAC permissions**

ğŸ”„ It is the **machine identity** for a podâ€”similar to how a `user` is a human identity.

---

## ğŸ¯ Why Use ServiceAccounts?

| Purpose                                | Description                                             |
| -------------------------------------- | ------------------------------------------------------- |
| Authenticate pods to Kubernetes API    | So internal apps can talk to Kubernetes securely        |
| Apply fine-grained RBAC permissions    | Limit what a pod can do using Role/ClusterRole bindings |
| Isolate security contexts              | Each app gets only the permissions it needs             |
| Integrate with external tools securely | Helm, Jenkins, CI/CD, etc.                              |

---

## ğŸ§± Default Behavior

* Kubernetes **automatically creates** a default `ServiceAccount` named `default` in each namespace.
* Unless specified, **pods use this default account**.

```bash
kubectl get serviceaccount default -n my-namespace
```

---

## ğŸ§¾ Anatomy of a ServiceAccount YAML

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: my-service-account
  namespace: my-namespace
```

This only defines the identity. It must be paired with **RBAC** to actually do anything.

---

## ğŸ” Token Mounting (Automatic by Default)

When a pod runs with a ServiceAccount, Kubernetes automatically:

* Mounts a token at `/var/run/secrets/kubernetes.io/serviceaccount/token`
* The pod can use this token to authenticate to the Kubernetes API

---

## âš™ï¸ How to Use a ServiceAccount with a Pod

### Step 1: Create a ServiceAccount

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: backend-sa
  namespace: backend
```

### Step 2: Use it in a Pod or Deployment

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-app
  namespace: backend
spec:
  serviceAccountName: backend-sa
  containers:
  - name: app
    image: nginx
```

Kubernetes will mount the SA token and use this identity for the pod.

---

## ğŸ›¡ï¸ Restrict Access with RBAC

### Step 3: Define Role and RoleBinding

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: read-pods
  namespace: backend
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list"]
```

```yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: backend-sa-binding
  namespace: backend
subjects:
- kind: ServiceAccount
  name: backend-sa
  namespace: backend
roleRef:
  kind: Role
  name: read-pods
  apiGroup: rbac.authorization.k8s.io
```

ğŸ” This gives `backend-sa` the ability to read pods in the `backend` namespace.

---

## ğŸš€ Real-World Use Case: Jenkins or CI/CD Access

Use `ServiceAccount` to authenticate from an external system (e.g., Jenkins) with a generated **kubeconfig**.

### Step-by-step:

1. Create `ServiceAccount`
2. Create `ClusterRoleBinding`
3. Generate a token:

   ```bash
   kubectl -n my-namespace create token cicd-sa
   ```
4. Build a kubeconfig manually using that token.

---

## ğŸ‘€ View ServiceAccount Details

```bash
kubectl describe serviceaccount backend-sa -n backend
```

Shows secrets, tokens, and any imagePullSecrets attached.

---

## ğŸ“¦ ImagePullSecrets with ServiceAccount

Attach private registry credentials:

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: deployer
secrets:
- name: regcred
```

---

## ğŸ” Best Practices

| Practice                             | Why It Helps                                   |
| ------------------------------------ | ---------------------------------------------- |
| Use one SA per app                   | Isolates permissions and improves auditability |
| Never use `default` SA in production | It's insecure and not auditable                |
| Pair SA with tightly scoped RBAC     | Least privilege principle                      |
| Disable automount if not needed      | Prevent token leaks                            |

```yaml
automountServiceAccountToken: false
```

---

## ğŸ”„ Bonus: Disable Automount (for extra security)

```yaml
spec:
  automountServiceAccountToken: false
```

Useful when you donâ€™t want the pod to talk to the Kubernetes API at all.

---

## ğŸ” Summary Table

| Feature              | Description                   |
| -------------------- | ----------------------------- |
| Identity Type        | Machine identity for pods     |
| Default Availability | One per namespace (`default`) |
| Can Be Customized?   | âœ… Yes, create your own        |
| Needs RBAC?          | âœ… Yes to be effective         |
| Mounted in Pods?     | âœ… Yes, auto by default        |
| Scope                | Namespaced                    |

---

Would you like a full example of:

* âœ… `ServiceAccount`
* âœ… `Role`
* âœ… `RoleBinding`
* âœ… `Pod` using the SA
  All in one bundle YAML?



-------------------------------------------------------------------------------

---

## ğŸ”¹ Scenario 1: **Jenkins Running Inside Kubernetes (as a Pod)**

âœ… You **can use `TokenRequest`** or even **auto-mounted tokens** inside the Pod. Hereâ€™s what applies:

### ğŸŸ¢ Option A: Auto-mounted ServiceAccount token

* Jenkins Pod has a `serviceAccountName`
* Kubernetes mounts a token at:

  ```
  /var/run/secrets/kubernetes.io/serviceaccount/token
  ```
* Jenkins uses that token to access the API

ğŸŸ  Risk: The token is **long-lived**, even if Jenkins restarts. If compromised, itâ€™s valid unless revoked.

---

### ğŸŸ¢ Option B: Use `TokenRequest` API (Best Practice)

* Inside the Jenkins pod, Jenkins (or a script) requests a **short-lived token** via Kubernetes API.
* The token has a short `expirationSeconds` and is **bound to Jenkins' identity**.

```bash
curl -s \
  --cacert /var/run/secrets/kubernetes.io/serviceaccount/ca.crt \
  -H "Authorization: Bearer $(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" \
  -H "Content-Type: application/json" \
  -X POST \
  -d '{"apiVersion":"authentication.k8s.io/v1","kind":"TokenRequest","spec":{"audiences":["https://kubernetes.default.svc"],"expirationSeconds":600}}' \
  https://kubernetes.default.svc/api/v1/namespaces/<your-namespace>/serviceaccounts/<sa-name>/token
```

âœ… **Preferred when Jenkins needs to call the Kubernetes API dynamically and securely.**

---

## ğŸ”¹ Scenario 2: **Jenkins Running Outside the Cluster (e.g., on a VM)**

Here, **Jenkins is not in Kubernetes**, so you canâ€™t use auto-mounted tokens or the in-cluster API shortcut `https://kubernetes.default.svc`.

### âœ… Recommended Approach:

1. **Manually request a short-lived token using TokenRequest** from a trusted in-cluster agent (or admin).
2. Or, **create a long-lived ServiceAccount token Secret**, and mount or inject it in Jenkins securely.

---

### âœ… Option A: Use TokenRequest via API (manual or automated)

You run this *from a Pod or script inside the cluster*, and return the token to Jenkins securely:

```bash
kubectl create token jenkins-deployer --duration=15m --namespace=cicd
```

You can then use the output token in Jenkins:

```bash
kubectl --server=https://<api-server> \
  --token=<retrieved-token> \
  apply -f deployment.yaml
```

---

### âš ï¸ Option B: Long-lived static token (Legacy method)

1. Create a `ServiceAccount`
2. Create a `Secret` of type `kubernetes.io/service-account-token`
3. Retrieve the token and add it to Jenkins credentials

```bash
kubectl -n cicd get secret <secret-name> -o jsonpath='{.data.token}' | base64 -d
```

ğŸ“› **Not ideal** â€” token never expires unless you rotate it manually.

---

## âœ… Summary: Which to Use?

| Where Jenkins Runs    | Recommended Auth Method               | Notes                            |
| --------------------- | ------------------------------------- | -------------------------------- |
| Inside Kubernetes Pod | `TokenRequest` with short TTL         | Secure and dynamic               |
| Inside Kubernetes Pod | Auto-mounted ServiceAccount token     | OK for simple or internal use    |
| Outside Kubernetes    | Manual `TokenRequest` or static token | Prefer short-lived; rotate often |

---
